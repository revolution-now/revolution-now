/****************************************************************
**map-gen.cpp
*
* Project: Revolution Now
*
* Created by dsicilia on 2022-04-21.
*
* Description: Game map generator.
*
*****************************************************************/
#include "map-gen.hpp"

// Revolution Now
#include "error.hpp"
#include "imap-updater.hpp"
#include "irand.hpp"
#include "terrain-mgr.hpp"

// ss
#include "ss/terrain.hpp"

// luapp
#include "luapp/register.hpp"

// refl
#include "refl/to-str.hpp"

// gfx
#include "gfx/iter.hpp"

// base
#include "base/logger.hpp"
#include "base/to-str-ext-std.hpp"

// C++ standard library
#include <algorithm>

using namespace std;

namespace rn {

namespace {

using ::gfx::Matrix;
using ::gfx::point;
using ::gfx::rect;
using ::gfx::rect_iterator;
using ::gfx::size;
using ::std::max;
using ::std::min;

} // namespace

// We cannot allow the player to build colonies on islands be-
// cause that would give the player a way to have a coastal
// colony that could not be attacked by the royal forces during
// the war of independence because they would have no adjacent
// land squares on which to land. This would basically cause the
// game to be unwinnable.
//
// Thus, the default game rules will not allow building a colony
// on an island, which includes an arctic island.
//
// However, it still is a good idea to remove islands from the
// map even though they wouldn't cause any problems. This is be-
// cause they add noise to the map and are useless to the player.
// Also, the OG removes islands.
void remove_islands( RealTerrain& real_terrain ) {
  Matrix<MapSquare>& m = real_terrain.map;
  for( point const p : rect_iterator( m.rect() ) )
    if( is_island( real_terrain, p ) )
      m[p].surface = e_surface::water;
}

// The land generated by the original game does not appear to
// have any land/water "crosses" in it, e.g.:
//
//                      L O            O L
//                      O L     or     L O
//
// Civilization 1 is known to have had a pass in the map genera-
// tion phase that removed these as a final stage of its map gen-
// eration, and so Colonization 1 is probably doing the same
// since they don't seem to appear on maps generated by the game.
// These crosses are not ideal visually because, if we render
// them then extra rendering complications are introduced because
// we need to signal to the player that the two water tiles are
// actually connected (a ship can sail between them); the naive
// rendering would draw the ocean squares as ocean singleton
// tiles and so there would be no visual indication that they are
// connected. It is possible that the OG wanted to simply avoid
// this complication and so it just removed them.
//
// The OG, however, is in fact able to properly render these
// crosses with a visual cue (thin blue "canal" between the diag-
// onally adjacent water tiles) to signal to the player that they
// are connected) as can be seen by creating maps containing them
// using the map editor. The NG can also render them similarly,
// and so it is technically not needed to remove them. But, we
// will do so by default here for two reasons: 1) the original
// game did it, and 2) we otherwise seem to end up with too many
// of them and they don't really look good even in the NG; they
// appear noisy on the map and still look a bit confusing.
//
// It is not trivial to remove them however, because the removal
// of one cross in a way that maintains total number of land
// tiles as a constant can introduce a new cross in the process.
// Multiple passes of such an algorithm them just cause the
// crosses to move around as almost as in a Game of Life. So here
// we employ two algorithms: the first one preserves land tile
// count after each cross removal and the second does not. We
// prefer the first algorithm and only apply the second if
// needed. Actually, even this can leave some crosses, and so we
// apply the composite twice and then stop; if there are still
// any crosses left, which is very rare (< 1/100000) then we will
// just live with it.
void remove_crosses( RealTerrain& real_terrain ) {
  auto& m = real_terrain.map;
  rect_iterator const tiles( m.rect().to_gfx().with_dec_size() );

  // Will return true if at least one cross was found. Note that
  // the cross(es) in question may have been removed and so may
  // no longer exist; but the fact that we found one means that
  // we should probably do another pass, which we signal by re-
  // turning true even if the cross was removed.
  auto const on_all_tiles =
      [&] [[nodiscard]] ( auto const& fn ) {
        bool found_cross = false;
        for( point const p : tiles )
          found_cross = fn( p ) || found_cross;
        return found_cross;
      };

  auto const corners = [&]( point const p ) {
    struct Corners {
      e_surface& nw;
      e_surface& ne;
      e_surface& sw;
      e_surface& se;
    };
    return Corners{
      .nw = m[p].surface,
      .ne = m[p.moved_right()].surface,
      .sw = m[p.moved_down()].surface,
      .se = m[p.moved_right().moved_down()].surface,
    };
  };

  // A cross is corrected by swapping two of its tiles that way
  // it doesn't change overall land density. When a swap happens
  // we end up with all the land on the left/right, or on the
  // top/bottom depending on which are swapped. We alternate be-
  // tween those two for visual balance.
  bool vertical = false;

  auto const method_swap = [&] [[nodiscard]] ( point const p ) {
    auto&& [nw, ne, sw, se] = corners( p );
    bool const is_cross     = nw == se && ne == sw && nw != ne;
    if( !is_cross ) return false;
    if( vertical )
      swap( nw, sw );
    else
      swap( nw, ne );
    vertical = !vertical;
    return true;
  };

  auto const method_add = [&] [[nodiscard]] ( point const p ) {
    auto&& [nw, ne, sw, se] = corners( p );
    bool const is_cross     = nw == se && ne == sw && nw != ne;
    if( !is_cross ) return false;
    nw = ne;
    return true;
  };

  auto const method_check = [&] [[nodiscard]] ( point const p ) {
    auto&& [nw, ne, sw, se] = corners( p );
    bool const is_cross     = nw == se && ne == sw && nw != ne;
    if( !is_cross ) return false;
    return true;
  };

  auto const remove = [&] {
    // The "swap" approach will often create a new cross during
    // the process of eliminating one. Thus, if there are still
    // crosses remaining after the "swap" method is applied then
    // we'll try the "add" method which seems less likely to
    // create new crosses, at the expense of slightly changing
    // the overall land density on each cross (but even there,
    // statistically different crosses should randomly raise or
    // lower it, so overall the density shouldn't change much).
    if( !on_all_tiles( method_swap ) ) return false;
    if( !on_all_tiles( method_add ) ) return false;
    return true;
  };

  auto const has_crosses = [&] {
    return on_all_tiles( method_check );
  };

  // Even after one pass, some crosses could be left because when
  // we fix one cross we may be creating another. An additional
  // pass seems to improve things, but there may still be crosses
  // left after this (not clear if it is possible to get rid of
  // them all with this algo).
  // iter();
  if( !remove() ) return;
  if( !remove() ) return;
  if( !remove() ) return;
  if( !remove() ) return;

  if( has_crosses() ) lg.warn( "crosses remaininging on map." );
  // Although we try our best to eliminate crosses, it may not be
  // possible to eliminate them all for every possible map using
  // the finite number of iterations above. In any case, the game
  // does support crosses, so it is fine to leave the few that
  // are remaining here.
}

// Outside of the land zone there will be no land tiles allowed
// with the exception of arctic tiles which will be added later.
//
// NOTE: generally these buffers do not need to be scaled with
// map size because exclusion around the map edges is done by the
// suppression mechanism; these buffers are just the minimum size
// in order to enforce a couple basic rules such as:
//   1. No land touching the left/right edge of the map.
//   2. The right edge should have at least a few squares of sea
//      lane so that the ship's starting position can't see land.
// Thus, we don't scale up the buffers when the map increases in
// size beyond the standard size. That said, we do scale them
// down for smaller map sizes, since e.g. for a 16x16 map a
// buffer of 3 on the right side is a bit too big.
[[nodiscard]] rect compute_land_zone( size const world_sz ) {
  auto const round_buffer = []( double const target ) {
    return min( max( lround( target ), 1L ), 10L );
  };

  // Note that arctic tiles are handled separately.
  int const h_top    = 1;
  int const h_bottom = 1;
  // See note above function for the purpose of these min's.
  int const w_left =
      round_buffer( 2.0 * min( world_sz.w / 56.0, 1.0 ) );
  int const w_right =
      round_buffer( 3.0 * min( world_sz.w / 56.0, 1.0 ) );

  return rect{ .size = world_sz }
      .with_new_top_edge( h_top )
      .with_new_bottom_edge( world_sz.h - h_bottom )
      .with_new_left_edge( w_left )
      .with_new_right_edge( world_sz.w - w_right );
}

// Instead of using a coin flip on each tile (which produces a
// bit too much randomness and not enough consistency and unifor-
// mity) we compute the number of tiles that we want and choose
// that exact number, that way we actually get the density that
// we want.
double place_arctic( RealTerrain& real_terrain, IRand& rand,
                     double const density ) {
  CHECK_GE( density, 0.0 );
  CHECK_LE( density, 1.0 );
  auto& m = real_terrain.map;

  int const w = m.size().w;

  int placed = 0;
  int total  = 0;

  auto const place_row = [&]( int const row ) {
    vector<point> v;
    v.reserve( w );
    for( int x = 0; x < w; ++x )
      v.push_back( { .x = x, .y = row } );
    rand.shuffle( v );
    int const n = clamp( lround( density * w ), 0l, ssize( v ) );
    for( int i = 0; i < n; ++i )
      m[v[i]].surface = e_surface::land;
    placed += n;
    total += w;
  };

  place_row( 0 );
  place_row( m.size().h - 1 );

  return double( placed ) / total;
}

void generate_proto_tiles( TerrainState& terrain ) {
  auto const set_arctic = []( MapSquare& square ) {
    square         = {};
    square.surface = e_surface::land;
    square.ground  = e_ground_terrain::arctic;
  };
  auto const set_sea_lane = []( MapSquare& square ) {
    square          = {};
    square.surface  = e_surface::water;
    square.sea_lane = true;
  };
  {
    using enum e_cardinal_direction;
    set_arctic( terrain.mutable_proto_square( n ) );
    set_arctic( terrain.mutable_proto_square( s ) );
    set_sea_lane( terrain.mutable_proto_square( e ) );
    set_sea_lane( terrain.mutable_proto_square( w ) );
  }
}

void reset_terrain( IMapUpdater& map_updater, size const sz ) {
  map_updater.modify_entire_map_no_redraw(
      [&]( RealTerrain& real_terrain ) {
        real_terrain.map = gfx::Matrix<MapSquare>( sz );
      } );
}

void linker_dont_discard_module_map_gen();
void linker_dont_discard_module_map_gen() {}

/****************************************************************
** Lua Bindings.
*****************************************************************/
namespace {

LUA_FN( remove_islands, void ) {
  st["IMapUpdater"]
      .as<IMapUpdater&>()
      .modify_entire_map_no_redraw( remove_islands );
}

LUA_FN( remove_crosses, void ) {
  st["IMapUpdater"]
      .as<IMapUpdater&>()
      .modify_entire_map_no_redraw( remove_crosses );
}

LUA_FN( create_arctic, void, double const density ) {
  IRand& rand = st["IRand"].as<IRand&>();
  st["IMapUpdater"]
      .as<IMapUpdater&>()
      .modify_entire_map_no_redraw(
          [&]( RealTerrain& real_terrain ) {
            place_arctic( real_terrain, rand, density );
          } );
}

} // namespace

} // namespace rn
