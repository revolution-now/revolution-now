/****************************************************************
**map-gen.cpp
*
* Project: Revolution Now
*
* Created by dsicilia on 2022-04-21.
*
* Description: Game map generator.
*
*****************************************************************/
#include "map-gen.hpp"

// Revolution Now
#include "error.hpp"
#include "imap-updater.hpp"
#include "terrain-mgr.hpp"

// ss
#include "ss/terrain.hpp"

// luapp
#include "luapp/register.hpp"

// refl
#include "refl/to-str.hpp"

// gfx
#include "gfx/iter.hpp"

// base
#include "base/to-str-ext-std.hpp"

// C++ standard library
#include <algorithm>

using namespace std;

namespace rn {

namespace {

using ::gfx::Matrix;
using ::gfx::point;
using ::gfx::rect;
using ::gfx::rect_iterator;
using ::gfx::size;
using ::std::max;
using ::std::min;

} // namespace

// We cannot allow the player to build colonies on islands be-
// cause that would give the player a way to have a coastal
// colony that could not be attacked by the royal forces during
// the war of independence because they would have no adjacent
// land squares on which to land. This would basically cause the
// game to be unwinnable.
//
// Thus, the default game rules will not allow building a colony
// on an island, which includes an arctic island.
//
// However, it still is a good idea to remove islands from the
// map even though they wouldn't cause any problems. This is be-
// cause they add noise to the map and are useless to the player.
// Also, the OG removes islands.
void remove_islands( RealTerrain& real_terrain ) {
  Matrix<MapSquare>& m = real_terrain.map;
  for( point const p : rect_iterator( m.rect() ) )
    if( is_island( real_terrain, p ) )
      m[p].surface = e_surface::water;
}

// The land generated by the original game does not appear to
// have any land/water Xs in it, e.g.:
//
//   L O            O L
//   O L     or     L O
//
// Civilization 1 is known to have had a pass in the map genera-
// tion phase that removed these as a final stage of its map gen-
// eration, and so Colonization 1 is probably doing the same
// since they don't seem to appear on maps generated by the game.
// These "x"s are not ideal visually because, if we are to render
// them, then extra rendering complications are introduced be-
// cause we need to signal to the player that the two water tiles
// are actually connected since a ship can sail between them (the
// naive rendering would draw the ocean squares as ocean sin-
// gleton tiles and so there would be no visual indication that
// they are connected). It is possible that the OG wanted to
// simply avoid this rendering complication and so it just re-
// moved them.
//
// The OG, however, is in fact able to properly render these Xs
// with a visual cue (thin blue "canal" between the diagonally
// adjacent water tiles) to signal to the player that they are
// connected) as can be seen when we can create maps containing
// them via the map editor. The NG can also render them simi-
// larly, and so it is technically not needed to remove them.
// But, we will do so by default here for two reasons: 1) because
// the original game did, and 2) we otherwise seem to end up with
// too many of them and they don't really look good even in the
// NG; they seem to add noise to the map and do actually still
// look slightly confusing to a player.
void remove_crosses( RealTerrain& real_terrain ) {
  auto& m      = real_terrain.map;
  rect const r = m.rect().to_gfx().with_dec_size();

  // A cross is corrected by swapping two of its tiles that way
  // it doesn't change overall land density. When a swap happens
  // we end up with all the land on the left/right, or on the
  // top/bottom depending on which are swapped. We alternate be-
  // tween those two for visual balance.
  bool vertical = true;

  auto const iter = [&] {
    for( point const p : rect_iterator( r ) ) {
      e_surface& nw = m[p].surface;
      e_surface& ne = m[p.moved_right()].surface;
      e_surface& sw = m[p.moved_down()].surface;
      e_surface& se = m[p.moved_right().moved_down()].surface;
      bool const is_cross = nw == se && ne == sw && nw != ne;
      if( !is_cross ) continue;
      if( vertical )
        swap( nw, sw );
      else
        swap( nw, ne );
      vertical = !vertical;
    }
  };

  // Even after one pass, some crosses could be left because when
  // we fix one cross we may be creating another. An additional
  // pass seems to improve things, but there may still be crosses
  // left after this (not clear if it is possible to get rid of
  // them all with this algo).
  iter();
  iter();
}

// Outside of the land zone there will be no land tiles allowed
// with the exception of arctic tiles which will be added later.
//
// NOTE: generally these buffers do not need to be scaled with
// map size because exclusion around the map edges is done by the
// suppression mechanism; these buffers are just the minimum size
// in order to enforce a couple basic rules such as:
//   1. No land touching the left/right edge of the map.
//   2. The right edge should have at least a few squares of sea
//      lane so that the ship's starting position can't see land.
// Thus, we don't scale up the buffers when the map increases in
// size beyond the standard size. That said, we do scale them
// down for smaller map sizes, since e.g. for a 16x16 map a
// buffer of 3 on the right side is a bit too big.
[[nodiscard]] rect compute_land_zone( size const world_sz ) {
  auto const round_buffer = []( double const target ) {
    return min( max( lround( target ), 1L ), 10L );
  };

  int const h_top    = 1;
  int const h_bottom = 1;
  // See note above function for the purpose of these min's.
  int const w_left =
      round_buffer( 2.0 * min( world_sz.w / 56.0, 1.0 ) );
  int const w_right =
      round_buffer( 3.0 * min( world_sz.w / 56.0, 1.0 ) );

  return rect{ .size = world_sz }
      .with_new_top_edge( h_top )
      .with_new_bottom_edge( world_sz.h - h_bottom )
      .with_new_left_edge( w_left )
      .with_new_right_edge( world_sz.w - w_right );
}

void reset_terrain( IMapUpdater& map_updater, size const sz ) {
  map_updater.modify_entire_map_no_redraw(
      [&]( RealTerrain& real_terrain ) {
        real_terrain.map = gfx::Matrix<MapSquare>( sz );
      } );
}

void linker_dont_discard_module_map_gen();
void linker_dont_discard_module_map_gen() {}

/****************************************************************
** Lua Bindings.
*****************************************************************/
namespace {

LUA_FN( remove_islands, void ) {
  st["IMapUpdater"]
      .as<IMapUpdater&>()
      .modify_entire_map_no_redraw( remove_islands );
}

LUA_FN( remove_crosses, void ) {
  st["IMapUpdater"]
      .as<IMapUpdater&>()
      .modify_entire_map_no_redraw( remove_crosses );
}

} // namespace

} // namespace rn
