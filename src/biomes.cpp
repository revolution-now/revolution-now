/****************************************************************
**biomes.cpp
*
* Project: Revolution Now
*
* Created by David P. Sicilia on 2026-02-13.
*
* Description: Assigns ground terrain types to a map.
*
*****************************************************************/
#include "biomes.hpp"

// Revolution Now
#include "error.hpp"
#include "irand.hpp"
#include "terrain-mgr.hpp"

// ss
#include "ss/terrain.hpp"

// config
#include "config/map-gen.rds.hpp"
#include "terrain-enums.rds.hpp"

// gfx
#include "gfx/iter.hpp"

// base
#include "base/expect.hpp"
#include "base/keyval.hpp"
#include "base/logger.hpp"
#include "base/timer.hpp"

namespace rn {

namespace {

using namespace std;

using ::base::expect;
using ::base::lookup;
using ::base::maybe;
using ::base::ScopedTimer;
using ::base::valid;
using ::base::valid_or;
using ::gfx::Matrix;
using ::gfx::point;
using ::gfx::rect_iterator;
using ::gfx::size;
using ::refl::enum_count;
using ::refl::enum_map;
using ::refl::enum_values;

[[maybe_unused]] static array<e_ground_terrain, 9> const
    kOrdering{
      e_ground_terrain::savannah,  //
      e_ground_terrain::grassland, //
      e_ground_terrain::tundra,    //
      e_ground_terrain::plains,    //
      e_ground_terrain::prairie,   //
      e_ground_terrain::desert,    //
      e_ground_terrain::swamp,     //
      e_ground_terrain::marsh,     //
      e_ground_terrain::arctic,    //
    };

/****************************************************************
** biome_curve
*****************************************************************/
struct biome_curve {
  [[maybe_unused]] biome_curve() = default;

  static expect<biome_curve> create( e_ground_terrain const gt,
                                     int const temperature,
                                     int const climate ) {
    biome_curve res;
    auto const& conf = config_map_gen.terrain_generation.biomes;
    res.curve_       = conf.normal_temperature_and_climate[gt];
    double const d_temperature =
        -clamp( temperature, -100, 100 ) / 100.0;
    double const d_climate =
        -clamp( climate, -100, 100 ) / 100.0;

    auto const apply_gradient = [&]( auto const member ) {
      res.curve_.params.*member *=
          ( 1 + conf.temperature_gradient[gt].*member *
                    d_temperature );
      res.curve_.params.*member *=
          ( 1 + conf.climate_gradient[gt].*member * d_climate );
    };

    using config::map_gen::BiomeCurveParams;
    apply_gradient( &BiomeCurveParams::weight );
    apply_gradient( &BiomeCurveParams::center );
    apply_gradient( &BiomeCurveParams::stddev );
    apply_gradient( &BiomeCurveParams::sub );

    GOOD_OR_RETURN( res.curve_.validate() );
    return res;
  }

  [[nodiscard]] double operator()( double const d ) const {
    CHECK_GE( d, 0.0 );
    CHECK_LT( d, 1.0 );
    // The sqrt( 2 ) here doesn't have the same meaning for
    // curves with exponents other than 2, but we'll leave it in
    // so that the formulas are the same except for exponent.
    static double const sqrt_2 = sqrt( 2.0 );

    auto const sample = [&]( double const x ) {
      double const a    = curve_.params.weight;
      double const mean = curve_.params.center;
      double const w    = curve_.params.stddev;
      double const sub  = curve_.params.sub;
      double const xp   = curve_.exp;
      return a * ( exp( -pow( ( ( x - mean ) / ( w * sqrt_2 ) ),
                              xp ) ) -
                   sub );
    };
    // The gaussians come in pairs in a way that is symmetric
    // about the equator, so when we sample one map row we need
    // to add the contributions from both.
    //
    // The offset by one (scaled) tile is needed for this reason:
    //
    //   1. The script that generates the curve parameters mir-
    //      rors the curves such that 35.5 is the center point,
    //      because it does (71-y). Recall that the parameters
    //      are generated by Lua where y starts at 1, hence its y
    //      was in [1,70] and thus it does 71-y to flip it, and
    //      therefore the center point is 35.5.
    //   2. The script shifts and scales the coordinate system
    //      before it outputs it for consumption by the C++ con-
    //      fig. It does (y-1)/70. Thus, in that coordinate sys-
    //      tem, the center point of mirroring is:
    //
    //        center = (35.5-1)/70 = (1/2)*(1-1/70)
    //
    //   3. Therefore, when we mirror, we need to mirror around
    //      the above center point, which we do by flipping the
    //      coording d by X-d, where X is 2*center:
    //
    //        X = (1-1/70) = 69/70.
    //
    return sample( d ) + sample( ( 69.0 / 70.0 ) - d );
  }

 private:
  config::map_gen::BiomeCurve curve_;
};

struct biome_dist {
  biome_dist(
      enum_map<e_ground_terrain, biome_curve> const& curves,
      double const o ) {
    double total = 0;
    for( auto const gt : enum_values<e_ground_terrain> ) {
      // Some curves can go below zero, e.g. the savannah and
      // swamp curves which are lowered slightly below the axis.
      // In that case they are interpreted as being zero in that
      // region.
      double const val   = std::max( curves[gt]( o ), 0.0 );
      probabilities_[gt] = val;
      total += val;
    }
    if( total > 0.0 )
      for( auto const gt : enum_values<e_ground_terrain> )
        probabilities_[gt] /= total;
    else
      for( auto const gt : enum_values<e_ground_terrain> )
        probabilities_[gt] = 1.0 / enum_count<e_ground_terrain>;
  }

  [[nodiscard]] double probability(
      e_ground_terrain const gt ) const {
    return probabilities_[gt];
  }

  [[nodiscard]] maybe<e_ground_terrain> sample(
      IRand& rand ) const {
    return rand.pick_from_weighted_values_safe( probabilities_ );
  }

  string to_str( e_ground_terrain const gt ) const {
    return format( "dist.{}={}", gt, probabilities_[gt] );
  }

 private:
  enum_map<e_ground_terrain, double> probabilities_;
};

/****************************************************************
** Adjacency.
*****************************************************************/
// Computes the adjacency of the tile as if the contents of the
// tile were `assumed`.
[[maybe_unused]] [[nodiscard]] double adjacency(
    MapMatrix const& m, point const tile,
    MapSquare const& assumed ) {
  CHECK( assumed.surface != e_surface::water );
  double res   = 0;
  auto const f = [&]( auto&& fn ) {
    on_surrounding( m, tile, fn );
  };
  f( [&]( point const, MapSquare const& adjacent ) {
    if( adjacent.surface == e_surface::water ) return;
    if( adjacent.ground == assumed.ground ) res += 1.0;
  } );
  return res;
}

[[nodiscard]] double adjacency( MapMatrix const& m,
                                point const tile ) {
  double res   = 0;
  auto const f = [&]( auto&& fn ) {
    on_surrounding( m, tile, fn );
  };
  MapSquare const& square = m[tile];
  f( [&]( point const, MapSquare const& adjacent ) {
    if( adjacent.surface == e_surface::water ) return;
    if( adjacent.ground == square.ground ) res += 1.0;
  } );
  return res;
}

[[nodiscard]] double adjacency_total(
    MapMatrix const& m, e_ground_terrain const biome ) {
  double res = 0;
  on_all_tiles(
      m, [&]( point const tile, MapSquare const& square ) {
        if( square.ground != biome ) return;
        res += adjacency( m, tile );
      } );
  return res;
}

// Computes the gravity of the tile as if the contents of the
// tile were `assumed`.
[[nodiscard]] double gravity(
    MapMatrix const& m, point const tile,
    MapSquare const& assumed,
    enum_map<e_ground_terrain, double> const& weights ) {
  using enum e_ground_terrain;
  CHECK( assumed.surface != e_surface::water );
  double res   = 0;
  auto const f = [&]( auto&& fn ) {
    on_surrounding( m, tile, fn );
  };
  if( assumed.ground == swamp ) {
    f( [&]( point const, MapSquare const& adjacent ) {
      if( adjacent.surface == e_surface::water )
        res += 2.0;
      else if( adjacent.ground == assumed.ground )
        res += 1.0;
      else if( adjacent.ground == marsh )
        res += 0.5;
    } );
  } else if( assumed.ground == marsh ) {
    f( [&]( point const, MapSquare const& adjacent ) {
      if( adjacent.surface == e_surface::water )
        res += 2.0;
      else if( adjacent.ground == assumed.ground )
        res += 1.0;
      else if( adjacent.ground == swamp )
        res += 0.5;
    } );
  } else {
    f( [&]( point const, MapSquare const& adjacent ) {
      if( adjacent.surface == e_surface::water ) return;
      if( adjacent.ground == assumed.ground ) res += 1.0;
    } );
  }
  return res * weights[assumed.ground];
}

[[maybe_unused]] void mix_row_by_gravity(
    MapMatrix& m, int const y,
    vector<int /*x*/> const& land_tiles, IRand& rand,
    enum_map<e_ground_terrain, double> const& weights ) {
  if( land_tiles.size() <= 1 ) return;
  int const x1 = rand.pick_one( land_tiles );
  int const x2 = rand.pick_one( land_tiles );
  if( x1 == x2 ) return;
  point const tile1  = { .x = x1, .y = y };
  point const tile2  = { .x = x2, .y = y };
  MapSquare& square1 = m[tile1];
  MapSquare& square2 = m[tile2];
  CHECK( square1.surface != e_surface::water );
  CHECK( square2.surface != e_surface::water );
  if( square1.ground == square2.ground ) return;
  auto const gravity_now =
      gravity( m, tile1, square1, weights ) +
      gravity( m, tile2, square2, weights );
  auto const gravity_swap =
      gravity( m, tile1, square2, weights ) +
      gravity( m, tile2, square1, weights );
  if( gravity_swap > gravity_now ) swap( square1, square2 );
}

[[maybe_unused]] void mix_row_by_adjacency(
    MapMatrix& m, int const y,
    vector<int /*x*/> const& land_tiles, IRand& rand,
    enum_map<e_ground_terrain, double> const& weights ) {
  if( land_tiles.size() <= 1 ) return;
  int const x1 = rand.pick_one( land_tiles );
  int const x2 = rand.pick_one( land_tiles );
  if( x1 == x2 ) return;
  point const tile1  = { .x = x1, .y = y };
  point const tile2  = { .x = x2, .y = y };
  MapSquare& square1 = m[tile1];
  MapSquare& square2 = m[tile2];
  CHECK( square1.surface != e_surface::water );
  CHECK( square2.surface != e_surface::water );
  if( square1.ground == square2.ground ) return;
  e_ground_terrain const gt1 = square1.ground;
  e_ground_terrain const gt2 = square2.ground;
  auto const gravity_now =
      adjacency( m, tile1, square1 ) * weights[gt1] +
      adjacency( m, tile2, square2 ) * weights[gt2];
  auto const gravity_swap =
      adjacency( m, tile1, square2 ) * weights[gt2] +
      adjacency( m, tile2, square1 ) * weights[gt1];
  if( gravity_swap > gravity_now ) swap( square1, square2 );
}

[[maybe_unused]] double gravity_total(
    MapMatrix const& m,
    vector<vector<int /*x*/>> const& land_tiles ) {
  double res                 = 0;
  int const total_land_tiles = [&] {
    int res = 0;
    for( point const p : rect_iterator( m.rect() ) )
      if( m[p].surface == e_surface::land ) ++res;
    return res;
  }();
  using enum e_ground_terrain;
  static enum_map<e_ground_terrain, double> const weights{
    { savannah, 1.0 },  //
    { grassland, 1.0 }, //
    { tundra, 1.0 },    //
    { plains, 1.0 },    //
    { prairie, 1.0 },   //
    { desert, 1.0 },    //
    { swamp, 1.0 },     //
    { marsh, 1.0 },     //
    { arctic, 1.0 },    //
  };
  for( int y = 1; y < ssize( land_tiles ); ++y ) {
    for( int const x : land_tiles[y] ) {
      point const tile{ .x = x, .y = y };
      res += gravity( m, tile, m[tile], weights );
    }
  }
  return res / total_land_tiles;
}

[[maybe_unused]] double gravity_total_for_biome(
    MapMatrix const& m,
    vector<vector<int /*x*/>> const& land_tiles,
    e_ground_terrain const biome ) {
  int const total_biome_tiles = [&] {
    int res = 0;
    for( point const p : rect_iterator( m.rect() ) )
      if( m[p].surface == e_surface::land &&
          m[p].ground == biome )
        ++res;
    return res;
  }();
  using enum e_ground_terrain;
  enum_map<e_ground_terrain, double> weights;
  double res     = 0;
  weights[biome] = 1.0;
  for( int y = 1; y < ssize( land_tiles ); ++y ) {
    for( int const x : land_tiles[y] ) {
      point const tile{ .x = x, .y = y };
      if( m[tile].ground != biome ) continue;
      res += gravity( m, tile, m[tile], weights );
    }
  }
  return res / total_biome_tiles;
}

[[maybe_unused]] [[nodiscard]] double relative_adjacency(
    MapMatrix const& m,
    map<int /*y*/, biome_dist> const& biome_dists,
    e_ground_terrain const biome ) {
  map<int /*y*/, int> const biome_count_per_row = [&] {
    map<int /*y*/, int> res;
    for( point const p : rect_iterator( m.rect() ) )
      if( m[p].surface == e_surface::land &&
          m[p].ground == biome )
        ++res[p.y];
    return res;
  }();
  map<int /*y*/, double> const avg_land_squares_in_row = [&] {
    map<int /*y*/, double> res;
    for( point const p : rect_iterator( m.rect() ) )
      if( m[p].surface == e_surface::land &&
          m[p].ground == biome )
        res[p.y] += num_surrounding_land_tiles( m, p );
    for( auto& [y, squares] : res ) {
      UNWRAP_CONTINUE( int const biome_count,
                       lookup( biome_count_per_row, y ) );
      squares /= biome_count;
    }
    return res;
  }();
  double adjacency_baseline = 0;
  for( auto const& [y, count] : biome_count_per_row ) {
    UNWRAP_CONTINUE( biome_dist const& row_dist,
                     lookup( biome_dists, y ) );
    UNWRAP_CONTINUE( double const avg_surrounding_land,
                     lookup( avg_land_squares_in_row, y ) );
    double const density_at_row = row_dist.probability( biome );
    double const adjacency_baseline_at_row =
        density_at_row * avg_surrounding_land * count;
    adjacency_baseline += adjacency_baseline_at_row;
  }
  double const adj_total = adjacency_total( m, biome );
  double const result    = adj_total / adjacency_baseline;
  return result;
}

} // namespace

/****************************************************************
** Public API.
*****************************************************************/
valid_or<string> assign_biomes( IRand& rand,
                                RealTerrain& real_terrain,
                                int const temperature,
                                int const climate ) {
  auto& m       = real_terrain.map;
  size const sz = m.size();

  enum_map<e_ground_terrain, biome_curve> curves;
  for( auto const gt : enum_values<e_ground_terrain> ) {
    UNWRAP_RETURN(
        curve, biome_curve::create( gt, temperature, climate ) );
    curves[gt] = curve;
  }

  // This should have been checked via the config validators
  // and/or map key validators.
  CHECK( sz.h % 2 == 0 );
  CHECK( sz.h > 1 );

  map<int /*y*/, biome_dist> biome_dists;

  for( int y = 0; y < sz.h; ++y ) {
    double const yd = double( y ) / sz.h;
    biome_dist const dist( curves, yd );
    biome_dists.emplace( y, dist );
    for( int x = 0; x < m.size().w; ++x ) {
      MapSquare& square = m[{ .x = x, .y = y }];
      // There would be no harm in distributing ground types on
      // water tiles, but we won't do it 1) for performance rea-
      // sons, and 2) because the rendering engine doesn't look
      // at them anyway (for water tiles that have some land on
      // the edges it will take the ground type from an adjacent
      // tile which is better for visual continuity anyway).
      if( square.surface == e_surface::water ) continue;
      auto const sample = dist.sample( rand );
      if( !sample.has_value() ) {
        for( auto const gt : enum_values<e_ground_terrain> )
          lg.warn( "{}: {}\n", gt, dist.to_str( gt ) );
        return format( "failed to sample biome at map row {}",
                       y );
      }
      // square.ground = *sample;
      square.ground = e_ground_terrain::prairie;
    }
  }

  // Adjacency adjustment.
  vector<vector<int /*x*/>> const land_tiles = [&] {
    vector<vector<int /*x*/>> res;
    res.resize( sz.h );
    for( point const p : rect_iterator( m.rect() ) )
      if( m[p].surface == e_surface::land )
        res[p.y].push_back( p.x );
    return res;
  }();

  enum_map<e_ground_terrain, double> const targets{
    { e_ground_terrain::savannah, 1.083 },  //
    { e_ground_terrain::grassland, 1.131 }, //
    { e_ground_terrain::tundra, 1.754 },    //
    { e_ground_terrain::plains, 1.143 },    //
    { e_ground_terrain::prairie, 1.121 },   //
    { e_ground_terrain::desert, 1.210 },    //
    { e_ground_terrain::swamp, 1.067 },     //
    { e_ground_terrain::marsh, 1.250 },     //
    { e_ground_terrain::arctic, 1.000 },    //
  };

  // Anti-glob.
#if 0
  {
    using enum e_ground_terrain;
    enum_map<e_ground_terrain, double> weights;
    for( auto const gt : enum_values<e_ground_terrain> )
      weights[gt] = -1.0;
    for( int iter = 0; iter < 100; ++iter )
      // Exclude artic rows.
      for( int y = 1; y < sz.h - 1; ++y )
        mix_row_by_adjacency( m, y, land_tiles[y], rand,
                              weights );
  }
#endif

  // Glob.
#if 0
  {
    using enum e_ground_terrain;
    enum_map<e_ground_terrain, double> weights;
    for( auto const gt : enum_values<e_ground_terrain> )
      weights[gt] = 1.0;
    int iter = 0;
    for( iter = 0; iter < 1000; ++iter ) {
      bool keep_going = false;
      for( auto const gt : enum_values<e_ground_terrain> ) {
        if( gt == e_ground_terrain::arctic ) continue;
        if( weights[gt] > 0 ) {
          double const g =
              relative_adjacency( m, biome_dists, gt );
          if( g > targets[gt] ) weights[gt] = 0.0;
        }
        if( weights[gt] != 0 ) keep_going = true;
      }
      if( !keep_going ) break;
      // Exclude artic rows.
      for( int y = 1; y < sz.h - 1; ++y )
        mix_row_by_adjacency( m, y, land_tiles[y], rand,
                              weights );
    }
    fmt::println( "\niters: {}", iter );
  }
#endif

#if 0
  fmt::println( "-----" );
  for( e_ground_terrain const gt : kOrdering ) {
    double const target = targets[gt];
    if( gt == e_ground_terrain::arctic ) continue;
    auto const g = relative_adjacency( m, biome_dists, gt );
    fmt::println(
        "{:10}: target={:0.3}, actual={:0.3}, error={:.3}%", gt,
        target, g, 100.0 * ( g - target ) / target );
  }
#endif

  return valid;
}

} // namespace rn
