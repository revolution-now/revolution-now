# ===============================================================
# trade-route.rds
#
# Project: Revolution Now
#
# Created by David P. Sicilia on 2025-10-26.
#
# Description: Rds definitions for the trade-route module.
#
# ===============================================================
# Revolution Now
include "goto.rds.hpp"

# ss
include "ss/trade-route.rds.hpp"

# gfx
include "gfx/cartesian.hpp"

# C++ standard library
include "<string>"

namespace "rn"

struct.CreateTradeRoute {
  name 'std::string',
  type 'e_trade_route_type',
  player 'e_player',
  stop1 'TradeRouteTarget',
  stop2 'TradeRouteTarget',
}

# This is so that we don't have to depend on the unit orders def-
# inition which pulls in other dependences.
struct.TradeRouteOrdersConfirmed {
    id 'TradeRouteId',
    # This is not advanced until the unit has unloaded at its
    # current stop and is actually moving toward the next stop.
    en_route_to_stop 'int',
}

# We include the route names here just in case the route ends up
# getting deleted as a result of the sanitization. That way, we
# can tell the player the name of the route (which we wouldn't be
# able to do if it got deleted).
sumtype.TradeRouteSanitizationAction {
  colony_no_longer_exists {
    route_name 'std::string',
  },
  colony_changed_player {
    colony_id 'ColonyId',
    route_name 'std::string',
  },
  no_harbor_post_declaration {
    route_name 'std::string',
  },
  empty_route {
    route_name 'std::string',
  },
  too_many_stops {
    route_name 'std::string',
  },
}

sumtype.EvolveTradeRoute {
  # Catch-all abort.
  abort {},
  # Specifically for aborting because we can't find a path.
  abort_no_path {},
  move {
    to 'e_direction',
  },
  sail_to_new_world {},
  # Normally when there are multiple consecutive stops on the
  # route that have the same target we process them all in one
  # turn. However, if the is only one unique stop for the entire
  # route (it may or may not appear multiple times) then we need
  # to wait a turn after loading/unloading to avoid going into an
  # infinite loop.
  wait_one_unique_stop {},
}
