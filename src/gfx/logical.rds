# ===============================================================
# logical.rds
#
# Project: Revolution Now
#
# Created by David P. Sicilia on 2024-10-25.
#
# Description: Rds definitions for the gfx/logical module.
#
# ===============================================================
# gfx
include "aspect.hpp"
include "cartesian.hpp"

# base
include "base/maybe.hpp"

# C++ standard library
include "<vector>"

namespace "gfx"

# ---------------------------------------------------------------
# Hardware inputs.
# ---------------------------------------------------------------
struct.Monitor {
  physical_screen 'size',
  dpi 'base::maybe<double>',
  diagonal_inches 'base::maybe<double>',
}

# ---------------------------------------------------------------
# Resolution Representations.
# ---------------------------------------------------------------
struct.NamedAspectRatio {
  name 'e_named_aspect_ratio',
  ratio 'AspectRatio',
}

struct.ResolutionAspectRatio {
  exact 'AspectRatio',
  closest_named 'base::maybe<NamedAspectRatio>',
}

# ---------------------------------------------------------------
# Resolution Representations.
# ---------------------------------------------------------------
struct.LogicalResolution {
  dimensions 'size',
  scale 'int',
  aspect_ratio 'ResolutionAspectRatio',
}

struct.Resolution {
  # This is the resolution not of the entire monitor but of the
  # game window (though the two may coincide) in native pixels.
  physical_window 'LogicalResolution',
  logical 'LogicalResolution',
  # This is in physical coordinates because 1) that is how it is
  # most useful, and 2) it can't generally be expressed in dis-
  # creet logical coordinates anyway because it may start on a
  # fractional logical coordinate.
  viewport 'rect',
  # The size of a pixel on screen in millimeters.
  pixel_size_mm 'base::maybe<double>',
}

struct.ResolutionAnalysis {
  resolutions 'std::vector<Resolution>',
}

# ---------------------------------------------------------------
# Resolution Selection Heuristics.
# ---------------------------------------------------------------
struct.ResolutionTolerance {
  min_percent_covered 'base::maybe<double>',
  fitting_score_cutoff 'base::maybe<double>',
}

struct.ResolutionRatingOptions {
  prefer_fullscreen 'bool',
  tolerance 'ResolutionTolerance',
  ideal_pixel_size_mm 'double',
  # When this is true, only one of each logical resolution will
  # be retained, namely the one with the best score. In practice
  # this means that, for a given logical resolution, only the one
  # with the largest scale factor will be kept. That said, it
  # technically depends on the pixel size score as well.
  remove_redundant 'bool',
}

# A score is in [0, 1.0] with 1.0 being best and 0.0 being worst.
struct.ResolutionScores {
  # The more of the screen it covers, the better.
  fitting 'double',
  # This scores based on the size of the logical pixels on the
  # screen after scaling. The closer it is to the specified tar-
  # get, the better.
  pixel_size 'double',
  overall 'double',
}

struct.RatedResolution {
  resolution 'Resolution',
  scores 'ResolutionScores',
}

struct.ResolutionRatings {
  # These are the ones that either fit the window exactly or fit
  # within it, such that there will be no part bleeding off the
  # edge of the window.
  available 'std::vector<RatedResolution>',

  # These are the ones that would have been in the 'viable' cate-
  # gory but did not meet the require tolerance requirements.
  unavailable 'std::vector<RatedResolution>',
}
