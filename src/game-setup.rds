# ===============================================================
# game-setup.rds
#
# Project: Revolution Now
#
# Created by David P. Sicilia on 2025-12-20.
#
# Description: Data representation of the information needed to
#              define a new game.
#
# ===============================================================
# Revolution Now
include "perlin-map.rds.hpp"

# config
include "config/options.rds.hpp"

# ss
include "ss/difficulty.rds.hpp"
include "ss/nation.rds.hpp"
include "ss/native-enums.rds.hpp"
include "ss/player-enums.rds.hpp"

# gfx
include "gfx/cartesian.hpp"

# rand
include "rand/entropy.hpp"

# refl
include "refl/enum-map.hpp"

# base
include "base/maybe.hpp"

# C++ standard library
include "<string>"

namespace "rn"

struct.NationSetup {
  name 'std::string',
  control 'e_player_control',
}

struct.NationsSetup {
  nations 'refl::enum_map<e_nation, base::maybe<NationSetup>>',
}

struct.TribeSetup {
  # TODO
}

struct.NativesSetup {
  tribes 'refl::enum_map<e_tribe, base::maybe<TribeSetup>>',
}

struct.SurfaceSanitizationSetup {
  remove_crosses 'bool',
  remove_islands 'bool',
}

struct.ArcticSetup {
  seed 'rng::seed',
  enabled 'bool',
  density 'double',
}

struct.SurfaceGeneratorSetup {
  perlin_settings 'PerlinMapSettings',
  arctic 'ArcticSetup',
  target_density 'double',
  sanitization 'SurfaceSanitizationSetup',
}

struct.GroundTypeSetup {
  seed 'rng::seed',
  temperature 'e_temperature',
  climate 'e_climate',
}

struct.RiverSetup {
  seed 'rng::seed',
  # This is the probability that, given a land square touching
  # water, we will start creating a river from it.
  density 'double',
  # This is the probability that a given river segment will be a
  # major river. This should really be smaller than .5 because
  # major rivers give a production bonus over minor rivers.
  major_river_fraction 'double',
}

struct.MountainsSetup {
  seed 'rng::seed',
  density 'double',
  # Probability that a tile chosen to have a mountain on it will
  # continue into a mountain range. This is applied recursively
  # on each new mountain tile added in the range to determine
  # whether to continue or not.
  range_probability 'double',
}

struct.HillsSetup {
  seed 'rng::seed',
  density 'double',
  # Probability that a tile chosen to have a hill on it will con-
  # tinue into a hill range. This is applied recursively on each
  # new hill tile added in the range to determine whether to con-
  # tinue or not.
  range_probability 'double',
}

struct.ForestSetup {
  seed 'rng::seed',
  density 'double',
}

struct.BonusesSetup {
  # This seed will be used to obtain an OG-style prime resource
  # seed which will then be used for both the prime resources as
  # well as the LCR placement, in accordance to how the OG does
  # it. We must do this otherwise it wouldn't be possible to have
  # interop between new and old save files.
  seed 'rng::seed',
}

# This will be the main body of the map exchange key, thus we
# should try not to change this once it is set.
struct.GeneratedMapSetup {
  # Map Size.
  size 'gfx::size',

  surface_generator 'SurfaceGeneratorSetup',

  ground_types 'GroundTypeSetup',

  rivers 'RiverSetup',

  mountains 'MountainsSetup',
  hills 'HillsSetup',
  forest 'ForestSetup',

  bonuses 'BonusesSetup',
}

enum.e_map_file_epoch {
  classic,
  modern,
}

enum.e_map_file_format {
  binary,
  json,
  rcl,
}

enum.e_map_file_contents {
  map_only,
  full_save,
}

struct.MapFileType {
  epoch 'e_map_file_epoch',
  format 'e_map_file_format',
  contents 'e_map_file_contents',
}

sumtype.MapSource {
  load_from_file {
    path 'std::string',
    type 'MapFileType',
    convert_islands_to_mountains 'bool',
    # If we need to generate prime resources/LCRs (typically we
    # will, unless we happen to be loading a modern map that al-
    # ready contains them) then this seed will be used, otherwise
    # it will be ignored.
    bonuses 'BonusesSetup',
  },
  generate_native {
    setup 'GeneratedMapSetup',
  },
  generate_lua {
    setup 'GeneratedMapSetup',
  },
}

struct.MapSetup {
  source 'MapSource',
}

struct.GameSettingsSetup {
  difficulty 'e_difficulty',
  starting_year 'int',
  rules 'config::options::Values',
}

# This struct contains all of the settings that can be specified
# (customized) to create a new game. The higher the level of cus-
# tomization that the player chooses, the more of these options
# will be customizable in the UI when creating a new game. When
# there is no customization at all then the vast majority of them
# will be selected automatically.
#
# These are in the reverse order in which they are selected, vis-
# ited and applied.
struct.GameSetup {
  settings 'GameSettingsSetup',
  nations 'NationsSetup',
  natives 'NativesSetup',
  map 'MapSetup',
}

struct.ClassicGameSetupParamsCommon {
  difficulty 'e_difficulty',
  player 'e_nation',
  player_name 'std::string',
}

struct.ClassicGameSetupParamsCustom {
  land_mass 'e_land_mass',
  land_form 'e_land_form',
  temperature 'e_temperature',
  climate 'e_climate',
}

struct.ClassicGameSetupParams {
  common 'ClassicGameSetupParamsCommon',
  custom 'ClassicGameSetupParamsCustom ',
}

struct.ClassicGameSetupParamsEvaluated {
  common 'ClassicGameSetupParamsCommon',
  land_density 'double',
  land_form 'PerlinLandForm',
  temperature 'e_temperature',
  climate 'e_climate',
}

enum.e_customization_mode {
  classic,
  modern,
  extreme,
}
