# ===============================================================
# game-setup.rds
#
# Project: Revolution Now
#
# Created by David P. Sicilia on 2025-12-20.
#
# Description: Data representation of the information needed to
#              define a new game.
#
# ===============================================================
# config
include "config/options.rds.hpp"

# ss
include "ss/difficulty.rds.hpp"
include "ss/nation.rds.hpp"
include "ss/native-enums.rds.hpp"

# gfx
include "gfx/cartesian.hpp"

# refl
include "refl/enum-map.hpp"

# base
include "base/maybe.hpp"

# C++ standard library
include "<string>"

namespace "rn"

struct.NationSetup {
  name 'std::string',
  human 'bool',
}

struct.NationsSetup {
  nations 'refl::enum_map<e_nation, base::maybe<NationSetup>>',
}

# This is set up so that its default value is what is used in a
# normal game.
struct.TribeSetup {
  disabled 'bool',
}

struct.NativesSetup {
  tribes 'refl::enum_map<e_tribe, TribeSetup>',
  # This is in [0,1] and gives a probability that a dwelling will
  # be placed on a tile assuming that all other conditions are
  # met. The OG appears to have ~6% of land tiles occupied by
  # dwellings. The number that we choose below is what leads to a
  # similar result given our algorithm.
  dwelling_frequency 'double',
}

enum.e_temperature {
  cool,
  temperate,
  warm,
}

enum.e_climate {
  arid,
  normal,
  wet,
}

sumtype.LcrSetup {
  none {},
  classic {},
}

sumtype.PrimeResourceSetup {
  none {},
  classic {},
}

enum.e_land_brush_type {
  single,
  cross,
  mixed,
  rand,
}

sumtype.LandGeneratorAlgorithm {
  seeded_organic {
    brush 'e_land_brush_type',
  },
  perlin {
    # TODO: add Perlin-specific parameters here.
  }
}

struct.LandGeneratorSetup {
  seed 'int',
  target_density 'double',
  # If we're removing Xs then this is the probabiliy we will do
  # so for each X found. Can be 0/1 for fully off/on.
  remove_Xs_probability 'double',
  remove_islands 'bool',
  generator_algo 'LandGeneratorAlgorithm',
}

struct.GeneratedTerrainSetup {
  # Map Size.
  # -------------------------------------------------------------
  size 'gfx::size',

  # Surface tile selection.
  # -------------------------------------------------------------
  land_generator 'LandGeneratorSetup',

  # Ground types.
  # -------------------------------------------------------------
  temperature 'e_temperature',
  climate 'e_climate',

  # Arctic.
  # -------------------------------------------------------------
  add_arctic_tiles 'bool',
  arctic_tile_density 'double',

  # Rivers.
  # -------------------------------------------------------------
  # This is the probability that, given a land square touching
  # water, we will start creating a river from it.
  river_density 'double',
  # This is the probability that a given river segment will be a
  # major river. This should really be smaller than .5 because
  # major rivers give a production bonus over minor rivers.
  major_river_fraction 'double',

  # Overlays.
  # -------------------------------------------------------------
  forest_density 'double',
  mountain_density 'double',
  # Probability that a tile chosen to have a mountain on it will
  # continue into a mountain range. This is applied recursively
  # on each new mountain tile added in the range to determine
  # whether to continue or not.
  mountain_range_probability 'double',
  hills_density 'double',
  hills_range_probability 'double',

  # Prime resources.
  # -------------------------------------------------------------
  prime_resources 'PrimeResourceSetup',

  # Lost City Rumors.
  # -------------------------------------------------------------
  lcr 'LcrSetup',
}

enum.e_map_file_epoch {
  classic,
  modern,
}

enum.e_map_file_format {
  binary,
  json,
  rcl,
}

enum.e_map_file_contents {
  map_only,
  full_save,
}

struct.MapFileType {
  epoch 'e_map_file_epoch',
  format 'e_map_file_format',
  contents 'e_map_file_contents',
}

sumtype.MapSource {
  load_from_file {
    path 'std::string',
    type 'MapFileType',
    convert_islands_to_mountains 'bool',
  },
  generate {
    terrain 'GeneratedTerrainSetup',
  },
}

struct.MapSetup {
  source 'MapSource',
  # If we need to generate prime resources/LCRs (typically we
  # will, unless we happen to be loading a modern map that al-
  # ready contains them) then this seed will be used, if provided
  # (mod 256). If this is needed but is not specified then a
  # random one will be chosen. If we are using the classic dis-
  # tribution algo then this corresponds to the exact
  # prime_resource_seed in the OG sav file.
  bonuses_seed 'base::maybe<int>',
}

struct.RulesSetup {
  values 'config::options::Values',
}

struct.TurnSetup {
  starting_year 'int',
}

struct.SettingsStateSetup {
  difficulty 'e_difficulty',
}

# This struct contains all of the settings that can be specified
# (customized) to create a new game. The higher the level of cus-
# tomization that the player chooses, the more of these options
# will be customizable in the UI when creating a new game. When
# there is no customization at all then the vast majority of them
# will be selected automatically.
#
# These are in the reverse order in which they are selected, vis-
# ited and applied.
struct.GameSetup {
  turns 'TurnSetup',
  nations 'NationsSetup',
  natives 'NativesSetup',
  map 'MapSetup',
  rules 'RulesSetup',
  settings_state 'SettingsStateSetup',
}

enum.e_customization_mode {
  classic,
  modern,
  extreme,
}
