Pixelating Landscape Tiles
=================================================================
There are cases where we need to pixelate a landscape tile from
one state to another. E.g., we want to depixelate some roads. To
do this in a general way without having to make temporary changes
to the terrain state and without having to do anything hacky, we
will have a new buffer that goes just above the landscape_annex
buffer, and will be called the landscape_anim buffer. This new
buffer is always empty except for during animations. During an
animation, it will contain the fully rendered set of tiles that
are animating (but no others, so it will be a small buffer) in
their target state. Then, the animation will consist of rendering
them on top of the landscape buffer with a gradual enpixelation,
so they will slowly cover the landscape tiles behind them (land-
scape tiles must never have any transparent pixels). In order to
avoid re-rendering those tiles in the landscape_anim buffer each
frame with a different pixelation stage, we will introduce a new
uniform into the shaders that, when not equal to 0.0, will intro-
duce a global depixelation (in this case, we will ramp it down
from 1.0 to create an enpixelation).

A similar method could eventually be used to e.g. enpixelate
fog-of-war when a unit is destroyed (by adding an
obfuscation-anim buffer), after the point at which we add a more
incremental fog-of-war updater mechanism. At the time of writing
we would not be ready for that because we only update the fog of
war at the start/end of each player's turn. An obfuscation anim
buffer could also be used to depixelate hidden terrain when a
treasure train enpixelates on a former dwelling tile that is
still adjacent to some other hidden tiles, although this is prob-
ably not a high priority.

RAII Planes Redesign
=================================================================

```cpp
// In the header.
struct FooPlane : public Plane {
  FooPlane(...);
  // This must be defined separately; if we default it here then
  // it will require access to the Impl destructor which we don't
  // have.
  ~FooPlane() noexcept; // = default but in the cpp.

private:
  struct Impl;
  std::unique_ptr<Impl> impl_;
};
```

Landscape Buffer
=================================================================

We need to have a giant vertex buffer for land rendering, which
we will refer to as the Landscape buffer. It will contain every-
thing represented in MapSquare pre-rendered (i.e., no units or
colonies). It will be re-uploaded to the GPU each frame (ini-
tially, although that may be optimized later). It will get its
own draw call which will always be first (since the land-view
plane is always first) and then all of the rest of the drawing
will be batched into a second draw call.

Overlap and Tile Draw Ordering
------------------------------

Before talking about the structure of the buffer, we need to es-
tablish some requirements that will make things much simpler and
give us a lot of flexibility. Specifically, we will impose that
the map squares and associated rendering have the following prop-
erties (which they currently do anyway):

  1. Changing anything on one tile cannot necessitate any changes
     to any other tiles except for those that are immediately ad-
     jacent.
  2. When the renderer renders a tile, it must render everything
     that will appear on that tile, even things that spill over
     from adjacent tiles. This is necessary otherwise the end re-
     sult of rendering would depend on the order in which the
     tiles are rendered which cannot work in general. Further-
     more, when rendering a tile, nothing will be rendered out-
     side of that tile, even things that should spill over. For
     simplicity, the renderer may violate this for rendering
     colonies and villages, but those are not relevant here be-
     cause they will not be in the landscape buffer.

(1) means that when e.g. we add a road to a tile, clear a forest
on a tile, or change a tile in the map editor, the number of
tiles that must be updated as a result are bounded. (2) means
that the end result of rendering the tiles in the buffer will be
independent of the order in which they are rendered. Crucially,
this means that when a tile is updated, we can just re-render the
tile (and adjacent tiles) by appending to the end of the buffer
and overwriting them.

Updating the Buffer
-------------------

When something on the land is updated, such as clearing a forest
or adding a road, the buffer must be updated. Given the con-
straints that we've imposed on tile rendering, there are a couple
of ways that we could make this happen:

  1. We can overwrite the vertices for the tiles in the buffer.
     There are two ways this could be done:
       a. Allocate a fixed number of vertices for each tile (the
          maximum number that any tile would need).
       b. Allocate only the number of vertices that each tile
          needs.
  2. We can leave the vertices as they are and append new ver-
     tices to the end of the buffer, effectively overwriting the
     tiles. When a certain threshold of tiles are redrawn we can
     redraw the entire buffer to save memory, although this may
     never really be necessary.
  3. Hybrid approach. In this approach we first render the tiles
     that have changed, count how many vertices there are, then
     we have a custom "allocator" that can manage allocations of
     vertices in the buffer (allowing us to free old ones and al-
     locate new ones, reusing space where possible).

Option 1.a would be simple in that it would be easy to know the
start/end vertex positions of a tile in the buffer, and it would
be easy to overwrite them. Also, the buffer would never grow.
Disadvantage would be that it would use a lot more memory than
needed, and it might be a pain to maintain the value representing
the necessary number of vertices as the renderer evolves (and
we'd have to figure out what to do if that number is unexpectedly
exceeded).

Option 1.b would have the advantage that it would use the least
amount of memory up front, but has the disadvantage that we'd
have to both store a map of the starting position/length of each
tile's vertices in the buffer, then when overwriting them we'd
have to potentially shift subsequent vertices up/down down in
memory and/or reallocate the buffer, which is not desirable.

Option 2 has the disadvantage that it will use more memory, and
will keep increasing as updates are made, and that therefore we
may have to have some mechanism of redrawing the map when the
number of vertices gets too large. But the advantage is that it
is super simple: we don't need to know the position of any ver-
tices in the buffer, we don't need to update any existing ver-
tices in the buffer, and we only need to append onto the end.
During the course of a real game, it is likely that the game will
be saved and reloaded multiple times during the course of a game
(and the map will be redrawn from scratch each time it is reload-
ed), and so it may not even be necessary to redraw the map from
scratch. Option2 also has the advantage that it will use very
little memory when most of the map is not visible. A disadvantage
here regarding the possibility of keeping the buffer on the GPU
would be that whenever the map is changed, the size of the buffer
will expand, and so the entire buffer will have to be re-uploaded
to the GPU with glBufferData instead of updated small segments of
it, but this may not turn out to be a problem since it doesn't
happen each frame.

Option 3 is complex since we have to design an allocator and keep
track of the start/end positions of tiles' vertices in the
buffer. The advantage theoretically is that it would tend to use
less memory as tiles are updated. Howver, in practice that might
not even be the case, since most of the time when tiles are up-
dated they either get revealed or they gain something on them
(such as a road) which will increase the number of vertices.
Therefore, for most of the game, it seems that gaps in the buffer
probably won't even be able to be reused, instead having to be
tacked onto the end.

Regarding storage of vertex buffer on the GPU: One potential ad-
vantage of 1.a is that, if the vertex buffer is stored on the
GPU, it could be easily updated with localized updates. Though
that may not be so important, since it is also fast to update the
entire buffer (which would have to happen with all of the other
options), especially given that it doesn't have to happen often.

It seems that the only desirable options would be either Option
1.a or Option 2. Since Option 2 is the simplest, we will just go
with that initially. The remainder will assume that we are going
with that approach.

Memory Usage Estimate
---------------------

In the case of a large map (200x200), we will have 40000 squares.
It is estimated that we will need at most 20 quads per square
(though most squares won't use them all, so this is an upper
bound on memory usage). Each quad has 6 vertices, and each vertex
is on the order of 100 bytes. So therefore we need this much
CPU/GPU memory at most:

  mem = (200*200) * 20 quads * 6 vertices * 100 bytes
      = 480,000,000 bytes
      = 457 MB

For a map size that the original game used (58x72) we have:

  mem = (58*72) * 20 quads * 6 vertices * 100 bytes
      = 50,000,000 bytes
      = 48 MB

at most.

How to handle visibility?
-------------------------

If a tile and its surroundings are not visible, then the vertex
buffer will simply contain a rendering of the cover (dark blue in
the original game, but could also be black), and thus will only
use 6 vertices. When a tile or one of its surroundings becomes
visible, those tiles will simply be redrawn at the end of the
buffer, completely covering up the cover tile.

When to redraw the buffer from scratch?
---------------------------------------

Initially we will assume that it won't be necessary to do this,
because, outside of the map editor, there is an upper bound on
how large the buffer could get even if every tile is e.g. made
visible and given a road. In that case, the above estimates would
probably be accurate. Furthermore, in practice, it is likely
that, during the course of a game, that the game will saved and
restored a few times, and each of those would cause the map to be
redrawn (and hence space-optimized) from scratch. So we will pro-
ceed assuming that it will not be necessary to ever totally re-
draw the map from scratch. If it does become necessary then it
shouldn't be too hard to add in a heuristic for when to do that.

rr::Renderer Changes
--------------------

The renderer will gain a second vertex buffer (actually, a vertex
array) called the landscape. It will be append-only in the sense
that it will not be cleared each frame. Instead, there will be a
special method to clear it which will only be called when a new
map is loaded at the start of a game. The interface will provide
a mod that can be used to select that buffer.

When ending a rendering pass, the landscape buffer will be up-
loaded (each frame). Later, we can add an optimization, e.g. a
dirty bit, which signals that the land scape buffer was modified
and that it needs to be re-uploaded. Note that when uploading it,
we need to use glBufferData since the size may have changed.

GenericVertex/Shader Changes
----------------------------

We need to introduce a concept of a camera to the rendering en-
gine. There will be a single camera in the engine, and it will be
set as a vec3 uniform, specifying the positino of the camera rel-
ative to the upper-left corner of the landscape. Also, there will
be a new GenericVertex attribute that marks a vertex as needing
to be translated/scaled according to the camera. Each frame, the
camera position will be updated.

The renderer API then needs to have a new method for setting the
camera position, and then land-view rendering needs to be changed
to just enable the camera for the vertices instead of position/s-
caling. Finally, the vertex shader needs to be updated to do the
relevant shifting/scaling.

Buffer Update Mechanism
-----------------------

We will need a mechanism for ensuring that any changes to a Map-
Square always trigger a redraw of the relevant vertices.

Idea: Change the interface in the world-map module to only return
const references to squares. Then add a new module called
map-updater that provides an interface for providing a mutable
square and then calling the appropriate redraw mechanisms auto-
matically. It is beneficial to have this as a separate module be-
cause the vast majority of code that needs access to the map
squares will not need to update them.

=================================================================
Coroutine-based GUI windows and widgets
=================================================================
       ________________________________________________
      /__________________Enter_Level___________________\
      |                                                |
      |  ( ) 5                                         |
      |  ( ) 10                                        |
      |  ( ) 15                                        |
      |  ( ) Slider                                    |
      |                                                |
      |  [-------------||||-------------------------]  |
      |                                                |
      |  Value: 4                                      |
      |                    __________     __________   |
      |                   /          \   /          \  |
      |                   |    OK    |   |  Cancel  |  |
      |                   \__________/   \__________/  |
      \________________________________________________/

  ```cpp
  struct actor {
    waitable<> coro;
    // Pointer to stream inside of coro.
    co::stream<>* strm;
  };

  template<typename Derived>
  struct view {
    actor place( view w, X x, Y y ) {
      co::stream<>* pings = nullptr;
      waitable<> coro = derived().run( pings, w, x, y );
      CHECK( pings != nullptr );
      return actor {
        .strm = pings,
        .coro = std::move( coro )
      };
    }

    virtual draw(where) = 0;
  };

  struct Button : view<Button> {
    bool down() const { return down_; }

    waitable<> run( co::stream<>*& pinger, view v, Coord c ) {
      co::stream<> pings;
      pinger = &pings;
      co::stream<input_t> input;
      auto placer = v.place( get_view(), c, input );

      while( true) {
        // Update state.
        switch( input_t in = co_await input.next() ) {
          case click_down:
            down = true;
            break;
          case click_up:
            if( down ) {
              down = false;
              // button click has happened.
              pings.send({});
            }
            break;
        }
      }
    }

    // State
    bool down_ = false;
  };
  ```

In user code:

  ```cpp
  int level = co_await get_level();

  waitable<maybe<int>> get_level() {
    window w = open_window();

    RadioButtons radios( "5", "10", "15", "Slider" );
    SliderControl slider( 1, 15 );
    OutputControl output( "Value: %d" );
    Button ok( "OK" );
    Button cancel( "Cancel" );

    // actor = coroutine + channel.
    actor c_radios = radios.place( w, x, y );
    actor c_slider = slider.place( w, x, y );
    actor c_output = output.place( w, x, y );
    actor c_ok     =     ok.place( w, x, y );
    actor c_cancel = cancel.place( w, x, y );

    co::interleave il(
      c_radios.strm,
      c_slider.strm,
      c_output.strm,
      c_ok.strm,
      c_cancel.strm
    );

    // State.
    // (none)

    while( true ) {
      // Update state.
      if( radio.selected() == "slider" ) {
        value = slider.value();
        slider.enable();
      } else {
        value = radio.selected_num();
        slider.disable();
      }
      output.set_val( value );

      auto o = co_await il.next();
      switch( o.index() ) {
        case e::ok:
          co_return output.get_value();
        case e::cancel:
          co_return nothing;
        default:
          break;
      }
    }
  }
  ```

=================================================================
Unit Composition
=================================================================

Types of requests that will need to be made:

  1. Given some set of commodities, what derived/base units can
     this unit become, along with the delta of commodities and
     modifiers required for each one.
  2. Can unit receive commodity, and if so how many and what unit
     type will it become?

Unit Type Representation and Conversion
=======================================

Types of unit conversion:

  - Soldier (petty criminal) to Soldier (iservant).
  - Soldier (iservant)       to Soldier (free col.).
  - Soldier (free col.)      to Veteran Soldier.
  - Dragoon to Veteran Dragoon.

  - Dragoon to soldier.
  - Veteran Dragoon to veteran soldier.
  - Soldier to colonist of some kind.
  - Veteran Soldier to veteran colonist.

  - Veteran Soldier to Continental Soldier.
  - Veteran Dragoon to Continental Dragoon.
  - Continental cavalry to continental soldier.
  - Continental soldier to veteran colonist.

  - Colonist to scout.
  - Scout (petty criminal) to Scout (iservant).
  - Scout (iservant)       to Scout (free col.).
  - Scout (free col.)      to Seasoned Scout.
  - Scout to colonist.
  - Scout to dragoon.
  - Seasoned Scout to dragoon.
  - Dragoon to scout (seasoned or regular).

  - Colonist to missionary.
  - Missionary (p.criminal) to Missionary (i.servant).
  - Missionary (i.servant)  to Missionary (free col.).
  - Missionary (free col.)  to Jesuit Missionary.
  - Missionary to colonist.

  - Petty Criminal to Indentured Servant.
  - Indentured Servant to Free Colonist.
  - Free Colonist to expert colonist.
      - Only certain types can get this through
        experience, the others must be purchased
        in europe or trained in a university.

  - Artillery to damaged artillery.

  - Colonist to pioneer.
  - Pioneer (petty criminal) to Pioneer (iservant).
  - Pioneer (iservant)       to Pioneer (free col.).
  - Pioneer (free col.)      to Hardy Pioneer.
  - Hardy Pioneer losing tools.
  - Hardy Pioneer to hardy colonist.
  - Pioneer losing tools.
  - Pioneer to colonist of some kind.
  - Pioneer to scout (loses tools and gains horses).

  - Braves/Armed Braves/Mounted Braves/Armed Warriors just die.
  - Braves gain muskets when winning against soldier.
  - Braves gain horses when winning against dragoon.
  - Mounted braves gain muskets when when winning
    against soldier.

  - Expert colonist to colonist (clearing specialty).

Sample paths:

  #1
    Indentured Servant
 -> Scout                    [equip with horses]
 -> Dragoon                  [equip with muskets]
 -> Dragoon (free colonist)  [equip with experience]
 -> Dragoon (veteran)        [equip with experience]
 -> Continental Dragoon      [equip with independence]
 -> Continental Soldier      [lose horses]
 -> Veteran colonist         [lost muskets, independence]
 -> Pioneer                  [gain tools]
 -> Pioneer (partial)        [lost some tools]
 -> Veteran colonist         [lost all tools]

  #2
    Artillery
 -> Damaged Artillery        [lose health]
 -> Destroyed                [lose health]

  #3
    Free Colonist
 -> Pioneer                  [equip with tools]
 -> Hardy Pioneer            [equip with experience]
 -> Hardy colonist           [lost tools]

The unit must somehow keep the following state:

  1. What unit is it originally (base type).
  2. What inventory does it have (including quantity):
      1. gold
      2. blessing
      3. horses
      4. muskets
      5. tools
      6. independence
  3. Cached derived type (eagerly evaluated).

Types of expertise that can be gained:
  1.  expert farmer
  2.  expert fisherman
  3.  expert sugar planter
  4.  expert tobacco planter
  5.  expert cotton planter
  6.  expert fur trapper
  7.  expert lumberjack
  8.  master carpenter
  9.  expert ore miner
  10. expert silver miner
  11. master distiller
  12. master tobacconist
  13. master weaver
  14. master fur trader
  15. master blacksmith
  16. master gunsmith
  17. veteran soldier
  18. hardy pioneer
  19. seasoned scout
  20. elder statesman
  21. jesuit missionary
  22. firebrand preacher



                 Action        Base Type                Equipment
-----------------------------------------------------------------
petty criminal                 petty-criminal
iservant         ExpCotton     iservant
scout            GainHorses    iservant                 [50-horses]
dragoon          GainMuskets   iservant                 [50-horses,50-muskets]
dragoon          GainVet       free-colonist            [50-horses,50-muskets]
dragoon          GainVet       veteran                  [50-horses,50-muskets]
cont. dragoon    GainIndep     veteran                  [50-horses,50-muskets,1-indep]
cont. soldier    LoseBattle    veteran                  [50-muskets,1-indep]
vet. colonist    LoseBattle    veteran                  []
pioneer          GainTools     veteran                  [100-tools]
pioneer          LoseTools     veteran                  [40-tools]
vet. colonist    LoseTools     veteran                  []
pioneer          GainTools     veteran                  [20-tools]
pioneer          ClearSp       free-colonist            [20-tools]
hardy pioneer    GainHardy     hardy-pioneer            [20-tools]
hardy pioneer    GainTools     hardy-pioneer            [40-tools]
hardy colonist   LoseTools     hardy-colonist           []
missionary       GainBlessing  hardy-colonist           [1-blessing]

Uservalue Ownership Semantics
=============================

A given userdata type must have a type traits (or ADL) special-
ization in order to be pushed/popped from the Lua stack. Further-
more, that specialization must choose precisely one ownership
model:

  1. Objects of that type are stored as C++ objects by value and
     are always owned by Lua.

  2. Objects of that type are stored as C++ objects owned by C++,
     and Lua always just holds references to them.

  3. The object has reference semantics, such as std::string_view
     or std::reference_wrapper; when these objects are pushed,
     they must push the object that they refer to according to
     its semantics. When they are gotten, a reference to the
     referred-to object is gotten and then the reference type is
     constructed from it.

  4. Objects of that type are converted to some Lua representa-
     tion when pushed, and thus are not pushed as userdata.

Objects owned by Lua (#1)
-------------------------

  These userdata objects will be given new() methods in their
  metatables to allow constructing new objects, and the signature
  of that constructor will be given in the type_traits.

  These userdata objects will have the is_native_ref() method in
  their metatables and it will return false.

    Type o;
    Type const& r1 = ...;
    Type& r2 = ...;

  For the translation from C++ to Lua:

    st["foo"]( o, r1, r2, Type{} );

    st["foo"] = []( ... ) -> Type const& {
      Type const& r = ...;
      return r;
    };

  All of those need to be copied pushed by value, to then be
  owned by Lua. This requires that Type be copyable.

  For the translation from Lua to C++:

    st["foo"] = []( Type o, Type const& r1, Type& r2, Type&& r3 ) {
      // Each of the reference parameters will be initialized
      // from a non-const lvalue reference to Type which lives
      // inside Lua.
    };

  That means that lua::get<Type>( ... ) must have only one overload
  in the traits struct or via ADL:

    maybe<Type&>     get( cthread L, int idx, tag<Type&> );
    maybe<Type&> lua_get( cthread L, int idx, tag<Type&> );

  Note that the returned reference to the object MUST be used be-
  fore the values are popped from the stack, since Lua could then
  free them immediately.

  The push functions can have two overloads:

    void push( cthread L, Type const& o ) {
      push_userdata_by_value( L, o );
    }
    void push( cthread L, Type&& o )  
      push_userdata_by_value( L, std::move( o ) );
    }

Objects owned by C++ (#2)
-------------------------
 
  These userdata objects will not have new() methods in their
  metatables since they can only really be created by C++.

  These userdata objects will have the is_native_ref() method in
  their metatables and it will return true.

    Type o;
    Type const& r1 = ...;
    Type& r2 = ...;

  For the translation from C++ to Lua:

    st["foo"]( o, r1, r2, Type{} );

  the first three will be pushed as references, and the last
  one will trigger a compile error.  For a C++ function returning
  the type, it cannot return by value and it cannot return
  by const ref, it must return by non-const ref:

    st["foo"] = []( ... ) -> Type& {
      Type& r = ...;
      return r;
    };

  otherwise there will be a compile error. For the translation
  from Lua to C++:

    st["foo"] = []( Type o, Type const& r1, Type& r2, Type&& r3 ) {
      // Each of the reference parameters will be initialized
      // from a non-const lvalue reference to Type which lives
      // inside C++. If the type is non-copyable, the first para-
      // meter will just trigger an error.
    };

  That means that lua::get<Type>( ... ) must have only one overload
  in the traits struct or via ADL:

    maybe<Type&>     get( cthread L, int idx, tag<Type&> );
    maybe<Type&> lua_get( cthread L, int idx, tag<Type&> );

  In this case, the stack values can be popped off of the stack
  without any risk of the returned references dangling. The push
  functions can have only one overload:

    void push( cthread L, Type& o ) {
      push_userdata_by_ref( L, o );
    }

  where the reference must be non-const.

Drag & Drop with Dialog Box
===========================

In general it will be necessary to allow the drag & drop frame-
work to pop up a dialog box and ask the user for more information
when a successfull drag is completed. In other words, when the
user releases the mouse to complete (what is or may be) a suc-
cessful drag a dialog box will pop up asking the user for input
before affecting the drag&drop action.

Some possible use cases for this could be:

  - Asking the user how much of a quantity they wish to drop
    (which it might do when the user holds down shift while drag-
    ging).
  - Asking the user to confirm the drag.

The following implementation assumes a future where both the drag
and drop framework as well as the relevant plane are operated
with finite state machines.

  - When the plane is notified that a drag is finished then we
    call the drag & drop class to handle it as usual.
  - If the resulting drag is verified to be valid then it will
    compute the drag arc as usual.
  - If valid, the drag & drop framework will set its state to
    "waiting for finalization."
  - The drag arc will then be given to the child class along with
    any necessary additional metadata to give the child a chance
    to alter it. This method will be called "finalize drag arc.":

      void finalize_drag_arc( DragArcT const& drag_arc ) const;

  - When the child has the result (which it may have immediately
    if no processing is necessary) then it will call an API
    method called "accept finalized drag arc." The framework will
    throw an error if this method is called when not in the ap-
    propriate state.

      void accept_finalized_drag_arc(
               Opt<CRef<DragArcT>> maybe_drag_arc ) final;

    If nullopt is provided then the drag will be cancelled.
  - The framework will test the resulting drag arc once more for
    validity. If invalid then it will throw an error (maybe).
  - If the drag is valid then it will transition to a "complete"
    state and will store the drag arc (not perform it).
  - As usual, when in the complete state, it will not accept any
    further drags until the stored one has been performed.
  - On the next frame, the plane will see the stored arc and will
    perform it by calling an API method called "perform drag if
    ready."
  - After performing the drag the framework will reset its state.

The following is an example of the workflow of the plane and
child drag&drop class during the "waiting for finalization" state
where a dialog box needs to be presented to the user to ask for
the quantity of commodity to be dragged:

  - As stated above, the framework will put itself into a
    "waiting for finalization state" and then call a child method
    with the drag arc.
  - The child class will add an event into the plane's event
    queue to signal to it to ask the user for quantity. This
    event can only be accepted when the plane is in the dragging
    state (though at first, try without dragging state as it may
    not be necessary).
  - The plane will then pop up the quantity box and wait for the
    user to enter. The result could either be OK (with a quantity
    or cancel) which would cancel the drag.
  - The window will be instructed that, when it closes, it should
    put its result (an Opt<int>) into an event and then add that
    event into the plane's event queue to signal that it has
    closed.
  - The plane will then transition back to the "waiting for drag"
    state (or the normal state) that it was in during the drag,
    and in so doing, it will call the drag&drop child's "accept
    quantity" function.
  - The "accept quantity" will then adjust the (stored) drag arc
    and then call the parent's "accept finalized drag arc" func-
    tion.

Old World Dock Screen
=====================

  - Create a dynamic square that is always centered but that can
    be dragged with a mouse to different sizes and aspect ratios.
    This will allow simulating screen dimensions while designing
    the UI without having to change the size of the window.
  - Create a series of old world UI objects; each of these ob-
    jects knows how to do the following:

      - Take a rectangle and then compute its configuration and
        position. From this can be computed a bounding rectangle.
      - Draw itself given configuration and position.
      - Determine if it is not possible to draw itself.

  - Each frame, all the UI elements will be asked to compute
    their positions and configurations. The scene will be X'd out
    if:

      - Any element cannot draw itself.
      - Any two elements overlap.
      - Any element runs out of bounds of the rectangle.

    Otherwise, the scene can be drawn.
  - Element positions/configurations will be cached with key
    being the rectangle size, although this may not be necessary.

Elements:

  - Outbound ships
  - Inbound ships
  - Ships in dock
  - Dock
  - Units on dock
  - Ship cargo
  - Market commodities
  - Exit button
  - Buttons
  - Message box
  - Stats area (money, tax rate, etc.)

Music Conductor (conductor.h/conductor.cpp)
===============

The `conductor` module is the interface that the rest of the game
uses to the music system. It performs the following roles:

  - Gathers all of the different music players.
  - Selecting/switching music player.
  - Taking commands from the user/game to control the music
    player, such as current tune, volume, play, stop, etc.
  - Managing the playlist. This includes figuring out which song
    to play when.

The interface will be a collection of functions in a namespace:

  namespace conductor {

  enum class e_music_player {
    silent,
    midiseq
  };

  enum class e_conductor_event {
    start_tune,
    finish_tune,
    volume_change,
    pause,
    resume,
    mplayer_changed
  };

  enum class e_music_state {
    playing,
    stopped,
    paused
  };

  enum class e_special_music_event {
    fountain_of_youth,
    king_raise_taxes,
    founding_father
  };

  struct ConductorInfo {
    e_music_player         mplayer;
    e_music_state          music_state;
    Opt<TunePlayerInfo>    playing_now;
    Opt<double>            volume;
    bool                   autoplay;
  };

  struct MusicPlayerInfo {
    bool        enabled;
    std::string name;
    std::string description;
    std::string how_it_works;
  };

  MusicPlayerInfo const& music_player_info( e_music_player mplayer );

  // Stops any playing music and changes the music player. Re-
  // turns true if success and false otherwise. If it fails then
  // no music player will be enabled.
  bool set_music_player( e_music_player mplayer );

  // Get the current state of the conductor. If no music players
  // are available then we get an `unexpected`.
  expect<ConductorInfo> state();

  // This will allow other code to recieve messages when the con-
  // ductor performs certain events. It will always send the no-
  // tification after the event. All functions are called in the
  // game's main thread.
  void subscribe_to_event(
        e_conductor_event, std::function<void(void)> );

  // If this is off then the conductor will never automatically
  // advance to the next tune when one is complete.
  void set_autoplay( bool enabled );

  // Play. If a tune is specified the it will start with that one
  // and then keep playing (from the random playlist if autoplay
  // is enabled). Otherwise, if a tune is not specified, it will
  // enable auto play and start playing.
  void play( Opt<TuneId> id );

  // Skip to beginning of this tune if > 5% progress, or previous
  // tune if < 5% progress. If progress is not available then
  // just skip to previous tune.
  void prev();

  // Skip to next tune in playlist. If we are paused this will go
  // into the stop state after advancing to the next tune. If we
  // are stopped then it will just advance to the next tune. In
  // any case it will not start player.
  void next();

  // Stop playing current tune (if playing) and forget current
  // place in tune.
  void stop();

  // If supported, stop playing but remember place in tune.
  void pause();

  // If supported, and if paused, resume playing.
  void resume();

  // If supported, jump to a certain place [0,1.0] in tune.
  void seek( double pos );

  // Tune Selection. Each of these methods will search through
  // available tunes and select one that meets the criteria and
  // then play it if requested. If the tune is played then the
  // conductor will return to autoplay when it is finished, if
  // autoplay is enabled.
  #define PLAY( what ) \
    TuneId what( bool play = true )

  namespace play {
    PLAY( won_battle_europeans );
    PLAY( won_battle_natives );
    PLAY( lost_battle_europeans );
    PLAY( lost_battle_natives );

    PLAY( slow_sad );
    PLAY( medium_tempo );
    PLAY( happy_fast );

    PLAY( orchestrated );
    PLAY( fiddle_tune );
    PLAY( fife_drum_sad );
    PLAY( fife_drum_slow );
    PLAY( fife_drum_fast );
    PLAY( fife_drum_happy );

    PLAY( native_sad );
    PLAY( native_happy );

    PLAY( king_happy );
    PLAY( king_sad );
    PLAY( king_war );
  }

  // Playlists.

  // Get full playlist and current tune (or next up if not play-
  // ing).
  std::pair<Vec<TuneId>,int> const& playlist();

  // Generate a random playlist. If one exists it will be regen-
  // erated (we will not merely shuffle here because the playlist
  // must satisfy some invariants).
  playlist_generate();

  // E.g. if we want a playlist that excludes all native tunes or
  // all post-revolution tunes. If playing this will take effect
  // on the next tune.
  playlist_generate_excluding( TuneOptDimensions dimensions );

  }

Initialization

When the conductor initializes it does a few things:

  - Generates a random playlist using playlist_generate().

  - Gathers a list of all available music players. Each music
    player will correspond to an enum value in e_music_player. A
    map will be created from enum to music player info and an-
    other map to MusicPlayer pointer (by calling the Music Play-
    er's static `player` method).

  - The conductor will set the active music player by consulting
    the config file for the first choice; if that is not avail-
    able there will be a second choice. If none of those are
    available then the first available one will be selected. If
    none are available then the conductor simply will not play
    music, though its API methods can still be called in general.
    It may be desirable during development to have the default
    music player be the "silent" one so that the game can still
    be tested with a music player enabled but no music will be
    produced until the music player is switched.

  - In order for a music player to be considered as enabled it
    must meet a few criteria. 1. good() == true. 2. The
    can_play_tune must return true for all tunes. The init rou-
    tine will check this.

  - The conductor will make sure that there is precisely one tune
    associated to each special music event, and this would come
    from the conductor's config file.

Playlist Generation

  For this it will first generate a random list of tunes,
  choosing among all the tunes who have purpose=standard. The
  length of this list will be 10 times the total number of tunes.
  This list must obey two constraints: 1. it cannot play a tune
  that was already played in the last five items in the playlist,
  unless there are fewer than five total tunes. 2. the last tune
  shall not be the same as the first tune. Finally, it will take
  the list and create an infinite cycle out of it effectively
  creating an infinite random-sounding playlist.

Tick

  Since the conductor does not run in its own thread it needs to
  be sent ticks on each frame so that it can manage things like
  autoplay. This will be done via a new frame-loop-subscription
  API in the frame module. The conductor module will supply a
  callback that does the following:

    - Maintains a counter and just increments the counter on each
      call. When the counter hits a threshold value (specified in
      config files) then the tick callback will perform its du-
      ties, otherwise it will just return and do nothing to avoid
      adding any overhead to the frame loop.

    - Will check up on the current music player to make sure that
      it is still in good condition. If not then it will attempt
      to switch to another music player.

    - If no tunes are playing and autoplay is enabled then it
      will kick off the next tune in the playlist.

  Note: this should be called each frame (will be lightweight)
  but the timing does not matter precisely, because e.g. this is
  not being used to generate music (that will always happen asyn-
  chronously for all music players).

Music Player (mplayer.h/mplayer.cpp)
============

Music will be played via Music Players. A music player is an ob-
ject that implements a music player interface with virtual meth-
ods. A concrete music player will derive from the base class.

Some possible concrete music players are:

  - OGG/WAV player
  - MP3 player
  - MidiSequencerMusicPlayer
  - MidiSynthesizerMusicPlayer
  - MidiOPLMusicPlayer

The MusicPlayer does not have a concept of playlist or any asso-
ciated concepts, such as "skip to next tune." Instead it focuses
on the playing of one tune at a time.

  // It is important to note when using this class that, in gen-
  // eral, calling the member functions may not cause instanta-
  // neous change to the real underlying music player for which
  // this class is a facade. This is because some music players
  // run in other threads and so these interface methods may
  // simply add commands into a queue to be consumed asynchro-
  // nously by the music-playing thread. Hence, change may not
  // take effect immediately and in some cases operations may
  // happen out of order.
  //
  // To help with this there is a method called `fence`. Calling
  // it will cause the calling thread to block until all previous
  // commands sent to the music player have been processed. It
  // also accepts a timeout to avoid hanging if something goes
  // wrong.
  class MusicPlayer {
  public:
    // Verifies that the tune exists on the filesystem in a
    // format that can be read by this player and that the file
    // can be opened. If successfull then it will return a Tune-
    // Info (so this means that it actually has to load and parse
    // the file).
    virtual Opt<TuneInfo> can_play_tune( TuneId id ) = 0;

    // Start playing the given tune from the beginning. When the
    // tune finishes it stops playing until it is given another
    // play command. Returns false if the tune cannot be played.
    virtual bool play( TuneId id ) = 0;

    // If playing will stop the player from playing music.
    virtual void stop() = 0;

    // Returns a structure giving the current state of the
    // player, such as whether it is playing a tune, progress
    // through the tune, volume, etc.
    virtual MusicPlayerState state() const = 0;

    // Returns info on what this music player is capable of do-
    // ing. E.g., can it seek within a tune, can it adjust vol-
    // ume, etc.
    virtual MusicPlayerCapabilities capabilities() const = 0;

    // -- Synchronization ---------------------------------------
    // To help ensure that operations on the music player are
    // well-ordered one calls `fence` before an operation that
    // must wait until previous operations have completed before
    // running. Calling it will cause the calling thread to block
    // until all previous commands sent to the music player have
    // been processed.
    //
    // It also accepts a timeout to avoid hanging if something
    // goes wrong. If a timeout occurs then the function returns
    // false, otherwise true.
    virtual bool fence( Opt<Duration_t> timeout );

    // This one is a more passive aid in making sure that music
    // player commands are well-ordered. It simply returns true
    // the music player is still processing previous commands. It
    // is guaranteed safe to send new commands to the music
    // player regardless of whether it is processing or not, but
    // one will might want to call this to aid in e.g. disabling
    // GUI elements while waiting for the music player to enact
    // the last command.
    virtual bool is_processing() const;

    // -- Optional Extensions -----------------------------------
    // The functions below may or may not be supported by a given
    // music player. If called on a player that doesn't support
    // them they will throw an exception on a debug build and
    // just log an error on a release build.

    // Pause playing of current tune. No-op if no tune is playing
    // or most recent tune has finished.
    virtual void pause();

    // Resume playing of paused tune. No-op if no tune is playing
    // or if most recent tune has finished.
    virtual void resume();

    // Get/Set current volume [0, 1.0].
    virtual void set_volume();

    // Seek to given position in current tune. position in [0,1].
    virtual void seek( double position );
  };

  struct MusicPlayerState {
    // TuneInfo struct for currently playing tune, if any.
    Opt<TuneInfo> tune_info;
    // If the player is currently playing a tune then it will re-
    // turn a number in [0,1.0] representing the progress through
    // the tune. Returns `nullopt` if no tune is playing or if
    // the most recent tune has finished.
    Opt<double> progress;
    // If the player is paused in the middle of a tune.
    bool is_paused;
    // If the player has a notion of settable volume then this
    // will be populated.
    Opt<double> volume;
  };

  struct TuneInfo {
    TuneId     id;
    Duration_t length;
  };

  struct MusicPlayerCapabilities {
    bool can_pause{false}; // implies that it can also resume
    bool has_volume{false};
    bool has_progress{false};
    bool has_tune_duration{false};
    bool can_seek{false};
  };

Each subclass must have a static method with signature:

  static MusicPlayerInfo const& player();

  struct MusicPlayerInfo {
    // E.g. "MIDI File Player"
    std::string name;

    // E.g. "Plays MIDI files using a player-supplied softsynth"
    std::string description;

    // E.g. "To use this music player you must have..."
    std::string how_it_works;

    // Will be non-null if the player successfully initialized
    // and is able to play music. Otherwise will contain an error
    // indicating why.
    expect<Ref<MusicPlayer>> player;
  }

If the player has been initialized properly and is able to play
music then the `player` member will refer to the (singleton) in-
stance of that player.

Tune Representation (tune.h/tune.cpp)
===================

Tunes and/or tune names will not be known at compile time. Tunes
will be referenced at runtime by IDs only. There should be no
part of a game that has a particular tune or tune name
hard-coded.

Tunes will be listed in the config files as a list of Tune ob-
jects that classify the tune along various enum dimensions:

  enum class e_tune_tempo           { fast, medium, slow };
  enum class e_tune_genre           { trad, classical };
  enum class e_tune_culture         { native, new_world, old_world };
  enum class e_tune_instrumentation { fife_and_drum, fiddle, percussive, orchestrated };
  enum class e_tune_sentiment       { happy, sad, war_triumph, war_lost };
  enum class e_tune_key             { a,bb,b,c,cs,d,eb,e,f,fs,g,ab };
  enum class e_tune_tonality        { major, minor };
  enum class e_tune_epoch           { standard, post_revolution }

The API for managing tunes will, to the furthest extent possible,
only use tune IDs and the above dimension enums. That way, it
will force client code to be written in such a way that does not
depend on the precise set of tunes that are available. For exam-
ple, we do not want a section of the game to say "when event X
happens play tune Y". Instead, it will say "when event X happens
play a tune that meets the following classification dimensions or
is as close to it as possible."

Despite the above, there will be an API for getting the name of a
tune for displayin the GUI. Also, the location of a tune (in a
particular format) on the filesystem will consist of a folder
path to the files of that type (specified in the config files)
joined with a string tune identifier (plus extension). The string
identifier will be available for each tune via the API, and must
follow these rules:

  - Must adhere to the regex: [a-z0-9-]+
  - Must be unique
  - Must correspond to the stem of the filename of the tunes in
    the filesystem (for any extention/type).

  struct Tune {
    string display_name;
    string stem;
    string description;

    // Classification.
    e_tune_tempo           tempo;
    e_tune_genre           genre;
    e_tune_culture         culture;
    e_tune_instrumentation instrumentation;
    e_tune_sentiment       sentiment;
    e_tune_key             key;
    e_tune_tonality        tonality;
    e_tune_epoch           epoch;
  };

The API for the tune module will be such as to deal in TuneId's
rather than string names, with the goal that client code should
not interact with tunes based on names in any way, but instead
should interact with them only through their classification di-
mensions.

UI Auto-Pad
===========

+--------------+-----------------------+------------------------+
|              |                       |                        |
|              |                       +------------------------+
|              |                       |                        |
|              |                       |                        |
|              +-----------------------+                        |
|              |                       |                        |
|              |                       |                        |
|              |                       |                        |
|              +-----------------------+------------------------+
|              |                                                |
|              |                                                |
|              |                                                |
|              |                                                |
|              |                                                |
|              |                                                |
|              |                                                |
|              |                                                |
|              |                                                |
+--------------+------------------------------------------------+

Algo:

  // f will take a view and put spacing in all the innards of it,
  // but not the outter edge.
  f( view v ) {
    for each child view cv of v:
      cv = f( cv )
     create hash map(s) to store borders added at this level.
    for each child view cv of v:
      for each side of cv:
        add padding if there is none touching it
  }

  f( main_view )

Mouse Selection of Units
========================

Problem: currently, when units are given Fortify or Sentry orders
there is not simple way to clear those orders, and there is no
way to use the mouse to select a unit for receiving orders.

In the viewport either at an end-of-turn or when units are
blinking one will be able to click on a square with units and ei-
ther clear their orders or ask them to ask for orders. The way
this works depends on how many units there are on a square.

1) Single unit (if ship, must have no units):

  a) During end of turn
    1. Has no orders
      No action.
    2. Has orders
      Orders are cleared.

  b) Not end of turn
    1. Has no orders
      The unit is placed at the front of the orders queue.
      Whether it moves this turn will depend if it has already
      moved or not. The unit currently asking for orders remains
      where it is in the queue (it will be processed just after
      the units that were moved to front).
    2. Has orders
      Orders are cleared.

2) All other cases

  a) During end of turn
      Opens window with recursive list of all units in square
      (including cargo units), prioritization disabled.

  b) Not end of turn
      Opens window with recursive list of all units in square
      (including cargo units), prioritization enabled.

Unit selection window:

Window will pop up listing the units in question. They will be
sorted with the following comparison function:

    operator<( unit1, unit2 ) {
      if unit1 can hold cargo and unit2 can not:
        true
      if unit1 is ship and unit2 is not:
        true
      if unit1 strength > unit2 strength:
        true
      false
    }

The units will have their orders shown in the nationality icon.
The player will then be able to click on the units. Upon clicking
on a unit the player will observe the following behavior. Each
click on a given unit will cycle the unit through the following
states (e.g., for a unit that is currently fortified):

    Orders=Fortified:
      Not End-of-turn:
        Fortified --> No Orders --> No Orders+Prioritized --> ...
      End-of-turn:
        Fortified --> No Orders --> ...
    Orders=None:
      Not End-of-turn:
        No Orders --> No Orders+Prioritized --> ...
      End-of-turn:
        No Orders --> ...

The window will have an creation option to disable the prioriti-
zation states and this will be used on end-of-turn.

On each click, the nat icon will change to reflect the orders
status, but the real underlying unit will not be modified until
the player clicks OK and closes the window. If the state is in a
"prioritized" one then there will be a white highlight/border
around the unit.

When finished the user can press OK to accept the changes, or
Cancel to cancel. "Accepting changes" here means that the under-
lying units will have their orders cleared as requested and pos-
sibly that some units will be moved to the front of the orders
queue.

After a unit has its orders cleared it will be eligible to move
in that same turn if it didn't already move in that turn. So
e.g., if a unit is Fortified in one turn they can be reactivated
in the same turn, but they won't be able to move again until the
next turn; this is because the act of fortifying will remove the
unit's movement points.

Graphical Layout:

The units will be arranged in a vertical line with their names
printed along side. Sorting of units is as described above.

Note that even units in the square that already have their orders
cleared will still show up in the window to avoid confusing the
player.

Implementation. There will be the following new views:

  - SpriteView: displays a sprite.

  - FakeUnitView: displays a unit and optionally a nat. icon, not
    necessarily corresponding to any real or existing unit. This
    will contain a SpriteView by composition.

  - ClickableView: a view that holds a single other view and
    adapts it into something clickable, that is, when clicked it
    calls a callback (does not pass the click through to the un-
    derlying view because that view would not handle it by as-
    sumption.

  - BorderView: a view that contains a boolean that, when true,
    causes a highlight/border of a given color to be painted
    around the contained view.

  - HorizontalArrayView: a view that takes multiple views and
    renders them horizontally with top/bottom/middle alignment.

  - PaddingView: a view that takes another view and just adds
    some padding around it.

  - VerticalArrayView: a view that wraps a list of views and dis-
    plays them vertically. This will inherit from VectorView. On
    creation, one can specify how to justify the views, either
    left, right, or center. This question of justification arises
    because the views in the array will generally have different
    widths.

  - VerticalScrollView: this will be needed because the contents
    will sometimes be too big to fit on screen. However, for now,
    it will be left as a stub with no scrolling.

  - OkCancelView: a view that contains an OK and Cancel button
    net to each other (can specify either vertically or horizon-
    tally) and provides a callback that indicates either OK or
    Cancel.

  - OkCancelAdapter: a view that takes another view and adds a
    pair of OK/Cancel buttons at the bottom using a VerficalAr-
    rayView containing two rows, one with adapted view and one
    with the buttons, layed out horizontally and centered hori-
    zontally.

Here is the view structure:

    OkCancelAdapter
    +-VerticalArrayView
      +-VerticalScrollView
      | +-VerticalArrayView
      |   |-...
      |   |-HorizontalArrayView
      |   | |-OneLineTextView
      |   | +-AddSelectBorderView
      |   |   +-ClickableView
      |   |     +-FakeUnitView
      |   |       +-SpriteView
      |   +-...
      +-OkCancelView
        |-ButtonView
        +-ButtonView

Then there will be a ok_cancel_window function will will take a
view and will use the OkCancelAdapter to show it in a window
along with two OK/Cancel buttons at the bottom and will keep the
window open until the user presses one of the buttons.

At that point, any changes made will be gathered and applied.
Calling unit.clear_orders() should be sufficient. Furthermore, if
there were any units selected for prioritization then this list
will be returned and applied by the `turn` module.

Eventually the VerticalScrollView can be implemented and that
will automatically add a scroll bar to the window if it gets too
vertically long.

Button Views
============

// Handles rendering the button in pressed, non-pressed, or dis-
// abled state, keeps track of state, renders text. Does not
// handle input, and has no callbacks.
class ButtonViewBase;

// Represents a button that springs back up when clicked. Handles
// input, and has a callback that gets called on each click.
class ButtonView;

Mouse Leave Events
==================

Mouse-Move events are only sent to the view that is under the
target coordinate of a mouse move. If the mouse moves out of a
view in a single jump then that view will not recieve notifica-
tion of this (to the view, it would be as if the mouse did not
move at all).

Therefore, when the mouse leaves a view there will be a mouse
leave event sent to it with this signature:

  virtual void on_mouse_leave();

There will be no mouse coordinates given because it is not sup-
pose to be relevant. For completeness and consistency (and be-
cause it will be easy to implement) there will also be a corre-
sponding mouse enter event:

  virtual void on_mouse_enter();

although technically this is not necessary since the view will
receive a mouse move event when the mouse enters.

The way this is implemented is the following. First add an API
method to the ui::Object class (pure virtual) that will be called
with a coordinate (relative to the view origin) and which will
add any views (either itself of children) into a set that overlap
that coordinate:

  using ObjectSet = absl::flat_hash_set<ui::Object const*>;
  virtual void children_under_coord( Coord where,
                                     ObjectSet& objects ) = 0;

Then, when the window manager receives a mouse motion event, it
will call the above function on both the previous position and
the current position and take the disjunction of the sets. Any
views under the old position but not the new position will have
their on_mouse_leave method called, and conversely for
on_mouse_enter.

Text Rendering with Markup
==========================

RN will have a mechanism for rendering text with markup to modu-
late the style. The user interface for this will be that the user
will be able to pass in some text with special markup syntax
among the text and this will be interpreted and rendered with the
appropriate style.

The workflow of this implementation (and its interaction with a
word wrap) will be as follows:

  1) The user provides some text which may contain some markup
     tags.
  2) The text is flattened onto a single line if it is multiline
  3) The text is then wrapped (if requested) in such a way that
     markup characters are ignored (but still remain intact)
     in the wrapping.
  4) Each resulting line is parsed for markup characters and
     translated into a vector of markup descriptor objects, with
     each object containing a segment of text.
  5) When parsing a given line, the start of the line will be
     given the markup state from the end of the last line.
  6) At this point we have a vector of self-contained lines
     each of which is a vector of markup descriptor objects.
     Each of these lines will be sent to a rendering function
     that will render them with caching at the line level.
     This rendering will be done one character at a time.
  7) Then the lines will be rejoined into a paragraph.

Initially, this will just focus on a single markup feature: high-
light or no highlight.  The syntax will be as follows:

  "This is a @Htest@N.  In@Hs@Nide letters can be highlighted."
  "This is an email@@address.com with escaping."

Menu Item Click Handling
========================

  Menu Module
  -----------

  In order to avoid all menu handler code going into the menu
  module, it will be possible for modules to register handlers
  for menu items. This will consist of a void( e_menu_item )
  function to handle a click on the menu item and a
  bool(e_menu_item) function to return if the menu item should be
  enabled or disabled. The functions take arguments so that a
  registerer can use the same function for multiple items and use
  branching within the function to distinguish menu items.

    MENU_ITEM_HANDLER( game, save, is_enabled_func, handler_func );

  will roughly expand to:

    STARTUP() {
      register_menu_item_handler(
        e_menu_item::save_game,
        handler_func,
        is_enabled_func
      );
    }

  All menu items must have precisely one handler registered, and
  this is enforced during initialization.

  The menu module will call the is_enabled_func for each menu
  item each frame (so they should be light-weight). If a menu
  item is not enabled then it will be shown as disabled. If all
  menu items in a menu are disabled then that menu will not be
  shown.

  When a menu item is clicked (and it is enabled) then the
  handler_func will be called.

  Plane Module
  ------------

  Although some menu items might have handlers registered
  throughout the code base, most menu items will have handlers
  registered in the `plane` module.

  The plane module's implementation of the two callback methods
  will call a new virtual method on each of the Plane objects
  that asks the Plane for a handler function for a particular
  menu item. Specifically, the Plane will return:

    using MenuHandler = function<void()>;

    OptRef<MenuHandler> f( e_menu_item item ) {
      if( item == e_menu_item::restore_zoom ) {
        static MenuHandler handler = [this] {

        };
        return handler;
      }
      if( item == e_menu_item::sentry ) {
        static MenuHandler handler = [this] {

        };
        return handler;
      }
      return nullopt;
    }

  The plane module will cycle through the planes (from outer to
  inner) to find the first plane that can handle the menu item
  (i.e., returns non-nullopt).

  If at least one Plane returns a result that is not nullopt then
  that is taken as an indication that the menu item is enabled
  (otherwise it is disabled), and the function object contained
  therein (from the top-most (enabled) Plane that returned one)
  will be called to handle it if it is clicked.

  This new virtual method on Plane will have a default implemen-
  tation that just returns nullopt.

Menus
=====

  User Experience
  ---------------

  There will be a menu bar at the top of the screen. The user,
  when the game is open for input, will be able to open a menu
  and select an item. Alternatively they can use Alt-<Key> and
  the arrow keys to open menus.

  The menus that appear will generally depend on the state of the
  game. For example, when the user enters the europe view an ad-
  ditional menu might appear that allows the user to perform ac-
  tions relevant there. This might supplement some buttons that
  are already in that view.

  At some points in the game, such as when AI nations are making
  their moves, the menus will be off, in which case the menu bar
  will be empty (perhaps with the exception of save/quit/pause;
  this is yet to be decided). If all menus are off then the menu
  bar will disappear, possibly with a sliding animation.

  When the user clicks a top-level menu it will open and remain
  open even after releasing the mouse button. Hovering the mouse
  over the menu items will highlight each item, unless it happens
  to be disabled. Clicking on a menu item will animate a brief
  flash. While the menu is open, the top-level menu name will be
  highlighted, and dragging the mouse over other top-level menu
  items will open that particular menu without necessitating more
  clicks.

  Dragging: the user can also interact with the menus in the
  "dragging style". In this way, the user selects a top-level
  menu and keeps the mouse button held down, then moves to a menu
  item and releases the button. Upon release of the button the
  menu item will be selected.

    * Selecting menu items may cause windows to open, but the
      consequences of this might have to be dealt with separately.
    * Some items might be disabled depending on general game state
    * If all items in a top-level menu are disabled then that
      menu will be hidden.
    * If a menu is open and the user clicks outside of all menu
      UI items then then menu will close and the click will have
      a click-through behavior where it will be resent through the
      planes (still to be decided).
    * There can be dividers between groupings of menu items.

  Most menus will be on the left side of the screen, but some may
  be right justified, such as the Revolopedia menu.

  There will be a global function that can turn on/off all menus;
  when this happens the menus will disappear (maybe).

  Rendering
  ---------

    * There will be a shadow under open menus.
    * Hot-key letter of menu will be highlighted.

Combat
======

From a high level: when a unit with non-zero attack attempts to
enter a square with a unit form another nation then:

  a) If the two nations are at peace then a yes/no box pops up
     asking for confirmation.
  b) If not at peace then the attack just proceeds.

When the move is first is attempted the combat stats and outcome
will be computed during the analysis phase, even before any
confirmation boxes are presented to the player. If the player
proceeds then the previously-computed outcome is animated and
carried out. However, even though the outcome of the combat is
known before the confirmation is presented, the player will
obviously not be presented with the outcome until deciding to
proceed and seeing the animation.

If a unit attempts to attack with less than a full movement point
then they will take a penalty for that.

If there are multiple units in the target square then the one with
the best defense will be picked.

Each attack will consume only one movement point, so some units
may be able to attack multiple times per turn.  If a unit gets
demoted after an attack the resulting number of movement points
will be min( X, Y ) where X is the max movement points for the
demoted unit and Y is the number of movement points that the
non-demoted unit would have had had the attack been successful.

Mouse Dragging
==============

The mouse dragging framework will span a few different frameworks:

  1) The `input` module that translates the raw SDL event.

      The `input` module will supply two pieces of information
      with each event: whether a drag is in progress (and, if so,
      the point from which the dragging started) and a signal as
      to when it finishes. The former will generally span many
      events while the latter will correspond to just a single
      event.

      This module will communicate to the next stage the fol-
      lowing information: if the `engaged` field of the mouse
      state is set then that means that the drag is either in
      progress or just finished. If the `done` flag is set then
      the drag is just finished; the receiver of this event must
      be sure to react to this `done` event because the drag
      state will be reset on the very next event.

  2) The Plane module

      The `plane` module will intercept the dragging events and
      propagate them to the planes in a different way. When it
      detects a dragging event it will send it to the planes not
      through the usual input way but through some dedicated
      methods that distinguish dragging start/middle/end. Fur-
      thermore, when a new dragging event starts and a plane ac-
      cepts it then that same plane will continue to receive the
      dragging events for that dragging move until it ends. This
      way a user cannot start dragging on one plane and drag onto
      another.

  3) (where relevant) the window module

Auto-commands
=============

It will be useful for various purposes:

  * Unit movement that happens as a result of some different
    command, such as:
      * land-fall automatically unloading a unit
      * combat capturing a unit
      * other things
  * Cut scenes (animated sequences)
  * Testing

for units to be able to take orders automatically instead of
polling the user.  To this end, we do the following:

  For units there will be a global orders queue that will hold
  player orders.  When a unit needs orders this queue will be
  checked first, and then the order will be taken a processed
  as if the user had entered it manually, including any popup
  windows that might be needed.

  If a unit needs orders and there are none in the queue then
  (and only then) will the user be polled.

Applications:

  * When a ship is making landfall then the first unit onboard
    with available movement points will be given an auto command
    to move onto land.  It will also be push to the front of the
    orders queue, and the ship will "wait".  The unit will then
    immediately execute the order.  All units on the ship with
    movement points will be given the order.

Planes
======

There will be a fixed, ordered list of planes. There will be a
global enum with values for each plane, and this enum will reside
in the plane module.

The plane objects themselves will reside in the module that han-
dles rendering to it, and will in general refer to methods in
that module for input handling and rendering. The plane objects
will be gathered by the plane module and held in a central loca-
tion, keyed off of the enum.

For each plane there will be a texture the size of the screen. To
render the screen the planes are drawn in order. We do not reuse
the same texture just in case a plane decides that it does not
need to render on every frame (e.g., a plane that just displays
an image would only need to do so once).

A plane has the following methods/attributes:

  - enabled
  - draw.  This method will be given the texture.  (which the
    plane module manages and which will be automatically set
    as the rendering target).  The texture will be initialized
    with zero alpha everywhere. The draw method will be given, as
    a parameter, a value indicating the phase of animations,
    one for periodic and another monotonically increasing.
  - accept input, returning true/false depending on whether
    the input was handled or not.
  - covers_screen. In that case, and if the plane is enabled,
    planes under it are not rendered since they would not be
    visible (for efficiency).

The plane module will handle executing the drawing routines to
assemble the composite of the planes and their layers.

Input handling: user input in general will be passed through the
planes starting with the outer most one until a plane decides to
handle that input, at which point no further planes will be given
the opportunity to handle it. A plane must know how to accept
input and change its state accordingly.

Planes:
  0) Land/Units
  1) Panel
  2) Colony View
  3) Europe View
  4) Menus
  5) Images
  6) Windows
  7) Console

The compositor will produce a final texture that can then be
rendered to the main one.

Units on ships:
===============

  ✓ Each time a ship moves, all the units it contains will have
    their orders changed to `sentry`, in case the player activated
    a unit but never moved it onto land.
  ✓ If a unit is activated on a ship and the ship is waiting for
    orders and the player either hits `wait` or `pass` then this
    will not change the status of the unit in any way.
  * If a player clicks on a ship and actives units then their orders
    will be cleared and, if they have not already moved this turn,
    they will ask for orders at some point before the end of the
    turn.  If this happens at the end of turn then the units will
    ask for orders next turn.
  ✓ If a unit is activated on a ship and is waiting for orders and
    the user presses `wait` then the game will come back to the
    unit, assuming that the ship did not move in the mean time
    (which would have changed the unit back to `sentry`).
  ✓ If a unit is waiting for orders on a ship and the player hits
    `pass` then the unit's orders will not change.
  ✓ If a unit is waiting for orders on a ship then the only valid
    commands are: movement onto land, movement onto ship, wait,
    pass, sentry.
  * A unit waiting for orders on a ship cannot attack direcly from
    the ship (maybe a special unit could do this).
  ✓ A unit waiting for orders on a ship can move onto an adjacent
    ship of the same nationality, which consumes all their movement
    points.
  ✓ When a unit boards a ship it consumes all their movement pts.
  ✓ When a unit offboards a ship it consumes all their movement pts.
  ✓ When a ship carrying units attempts to move onto land:
     ✓ The ships movement points are NOT consumed.
     ✓ If there are no units with movement points then nothing happens.
     ✓ If there are units with movement points then:
        ✓ A window pops up asking if we want to make landfall.
        ✓ If yes, the following happens:
            ✓ All the units with movement points on the ship have
              their orders cleared.
            ✓ The units in the ship with movement
              points moves onto the land automatically.
            ✓ All the other units on the ship with movement points
              are put on the priority list to take orders next.
            ✓ The ship itself is given a `wait` order automatically.
            ✓ As a consequence of the above, the next unit on board
              with movements points starts to blink.

================================================================

Game loops:
==========

  start of turn:

    Iterate through the colonies, for each:

      * advance state of the colony

      * display messages to user any/or show animations where necessary

      * allow them to enter colony when events happens;
        in that case go to the colony screen game loop.When the user
        exits the colony screen then this colony iteration
        immediately proceeds;
        i.e., user cannot enter any other colonies.  This prevents the
        user from making last-minute changes to colonies that have not
        yet been advanced in this turn (otherwise that might allow
        cheating in some way).

      * during this time, the user is not free to scroll
        map (menus?) or make any changes to units.  They are also
        not allowed to enter colonies apart from the one that has
        just been processed.

    Advance the state of the old world, possibly displaying messages
    to the user where necessary.

    Iterate through all units, for each:

      * if it is it in `goto` mode focus on it and advance it
      * if it is a ship on the high seas then advance it
          if it has arrived in the old world then jump to the old world
          screen (maybe ask user whether they want to ignore),
          which has its own game loop (see old-world loop).
      * if it is in the old world then ignore it, or possibly remind
        the user it is there.
      * if it is performing an action, such as building a road,
        advance the state.  If it finishes then mark it as active
        so that it will wait for orders in the next step.
      * if it is in an indian village then advance it, and mark
        it active if it is finished.

      * if unit is waiting for orders then focus on it, and enter
        a realtime game loop where the user can interact with the
        map and GUI in general.  See `unit orders` game loop.

      * Make AI moves
          Make European moves
          Make Native moves
          Make expeditionary force moves

          Might want to do this in the Processing loop

      * if no player units needed orders then show a message somewhere
        that says "end of turn" and let the user interact with the
        map and GUI.

  Unit orders game loop:

    while state != unit accepted orders:

      render:
        render the the world without any units on it.  Color cycling
        animations here will use SDL_GetTicks to decide animation state.

        render all the colonies

        render all the units, with the focus animation using SDL_GetTicks
        to decide animation state.

      if state == unit awaiting orders && if input received:
        check if input valid
        if so then iniate movement animation, setting state to animation.
        ? need to figure this out more, but initially skip animations ?

      if state == animation:
        advance animation;
        if animation finished the mark state as
        `unit accepted orders`

      delay to maintain frame rate

  End of turn game loop:

  Colony screen game loop:

  Old World game loop:

  Message-window-over-world game loop:

    * This needs needs to be able to show a message and let the
      user interact with it while possibly still showing animations
      on the map in the background, but not letting the user interact
      with the map.

  Unit animation game loop: (needed?)

    * This includes sliding units and animations resulting from
      e.g. city upgrades.

  Processing game loop:

    * Any intensive processing task should probably be done in
      a separate thread with a loop running so that things remain
      responsive.
